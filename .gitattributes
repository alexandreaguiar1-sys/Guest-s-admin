local Player = game.Players.LocalPlayer

Player.Chatted:connect(function(cht)


 if cht:match("<reset>") then
game.Players.LocalPlayer.Character:BreakJoints()


  elseif cht:match("<load server sided bypass>") then

  
spawn(function()
    while true do
        game.Players.LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)*math.huge
        game.Players.LocalPlayer.SimulationRadius = math.pow(math.huge,math.huge)*math.huge
        game:GetService("RunService").Stepped:wait()
    end
end)
game["Run Service"].Stepped:connect(function()
game.Players.LocalPlayer.Character.Tors.CanCollide = false
game.Players.LocalPlayer.Character.Head.CanCollide = false
end)
game.Players.LocalPlayer.CharacterAdded:connect(function()
game.Players.LocalPlayer.Character:WaitForChild("Right Arm")
wait(0.1)
rs = game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Clone()
game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Destroy()
rs.Parent = game.Players.LocalPlayer.Character.Torso
rs.Part0 = game.Players.LocalPlayer.Character.Torso
rs.Part1 = game.Players.LocalPlayer.Character["Right Arm"]:Clone()
game.Players.LocalPlayer.Character["Right Arm"].Name = "ra"
rs.Part1.Parent = game.Players.LocalPlayer.Character
local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Right Arm"])
local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["ra"])
local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Right Arm"])
ol.Attachment0 = Attachment0
ol.Attachment1 = rightarm
ol.LimitsEnabled = true
ol.LowerAngle = 0
ol.Restitution = 0
ol.UpperAngle = 0
ls = game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Clone()
game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Destroy()
ls.Parent = game.Players.LocalPlayer.Character.Torso
ls.Part0 = game.Players.LocalPlayer.Character.Torso
ls.Part1 = game.Players.LocalPlayer.Character["Left Arm"]:Clone()
game.Players.LocalPlayer.Character["Left Arm"].Name = "la"
ls.Part1.Parent = game.Players.LocalPlayer.Character
local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Left Arm"])
local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["la"])
local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Left Arm"])
ol.Attachment0 = Attachment0
ol.Attachment1 = rightarm
ol.LimitsEnabled = true
ol.LowerAngle = 0
ol.Restitution = 0
ol.UpperAngle = 0
rh = game.Players.LocalPlayer.Character.Torso["Right Hip"]:Clone()
game.Players.LocalPlayer.Character.Torso["Right Hip"]:Destroy()
rh.Parent = game.Players.LocalPlayer.Character.Torso
rh.Part0 = game.Players.LocalPlayer.Character.Torso
rh.Part1 = game.Players.LocalPlayer.Character["Right Leg"]:Clone()
game.Players.LocalPlayer.Character["Right Leg"].Name = "rh"
rh.Part1.Parent = game.Players.LocalPlayer.Character
local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Right Leg"])
local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["rh"])
local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Right Leg"])
ol.Attachment0 = Attachment0
ol.Attachment1 = rightarm
ol.LimitsEnabled = true
ol.LowerAngle = 0
ol.Restitution = 0
ol.UpperAngle = 0
lh = game.Players.LocalPlayer.Character.Torso["Left Hip"]:Clone()
game.Players.LocalPlayer.Character.Torso["Left Hip"]:Destroy()
lh.Parent = game.Players.LocalPlayer.Character.Torso
lh.Part0 = game.Players.LocalPlayer.Character.Torso
lh.Part1 = game.Players.LocalPlayer.Character["Left Leg"]:Clone()
game.Players.LocalPlayer.Character["Left Leg"].Name = "lh"
lh.Part1.Parent = game.Players.LocalPlayer.Character
local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Left Leg"])
local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["lh"])
local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Left Leg"])
ol.Attachment0 = Attachment0
ol.Attachment1 = rightarm
ol.LimitsEnabled = true
ol.LowerAngle = 0
ol.Restitution = 0
ol.UpperAngle = 0
r = game.Players.LocalPlayer.Character.HumanoidRootPart["RootJoint"]:Clone()
game.Players.LocalPlayer.Character.HumanoidRootPart["RootJoint"]:Destroy()
r.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
r.Part0 = game.Players.LocalPlayer.Character.HumanoidRootPart
r.Part1 = Instance.new("Part", game.Players.LocalPlayer.Character)
r.Part1.Size = Vector3.new(2,2,1)
r.Part1.Name = "Tors"
r.Part1.Parent = game.Players.LocalPlayer.Character
local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character.Tors)
local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character.Torso)
local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character.Tors)
ol.Attachment0 = Attachment0
ol.Attachment1 = rightarm
ol.LimitsEnabled = true
ol.LowerAngle = 0
ol.Restitution = 0
ol.UpperAngle = 0
char = game.Players.LocalPlayer.Character
repeat wait()until char:FindFirstChildOfClass("Accessory")
wait(0.1)
for i,v in pairs (char:GetChildren()) do
if v:IsA("Accessory") and v:FindFirstChild("Handle") and v:FindFirstChild("Handle"):FindFirstChild("AccessoryWeld").Part1 == char.Head then
local Attachment0 = Instance.new("Attachment", char.Head)
local rightarm = Instance.new("Attachment", v.Handle)
local ol = Instance.new("HingeConstraint", char.Head)
ol.Attachment0 = Attachment0
ol.Attachment1 = rightarm
ol.LimitsEnabled = true
ol.LowerAngle = 0
ol.Restitution = 0
ol.UpperAngle = 0
rightarm.CFrame = v.AttachmentPoint + Vector3.new(0, -0.5, 0)
v.Handle.AccessoryWeld:Destroy()
end
end
end)
game.Players.LocalPlayer.Character.Humanoid.Health = 0
while wait() do
repeat wait() until game.Players.LocalPlayer.Character
char = game.Players.LocalPlayer.Character
for i,v in pairs (char:GetDescendants()) do
if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0,0,0)
v.Massless = true
v.CanCollide = false
end
end
end

elseif cht:match("<load Bypass>") then

HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end

if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end

   elseif cht:match("<load Bypass v>") then


HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
	AttachmentC.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

function nocollision(Parented,Part)
    for _,v in pairs(Parented:GetChildren()) do
        if v:IsA("BasePart") then
            local nocol = Instance.new("NoCollisionConstraint")
            nocol.Part0 = Part
            nocol.Part1 = v
            nocol.Parent = Part
        end
    end
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true 
local CloneChar = game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:Clone()
CloneChar.Parent = game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain")
CloneChar.HumanoidRootPart.CFrame = game:FindFirstChildOfClass("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non" 
CloneChar.Humanoid.DisplayDistanceType = "None"

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

for _,v in next, DeadChar:GetChildren() do
    if v:IsA("Accessory") then
        if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
        local bv = Instance.new("BodyVelocity",v.Handle)
        bv.Velocity = Vector3.new(0,1,0)
        SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
    end
end

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

for _,v in pairs(DeadChar:GetChildren()) do
    if v:IsA("BasePart") then
        nocollision(CloneChar,v)
    end
end

local con
function UnCollide()
    if HumanDied then con:Disconnect(); return end
    for _,Parts in next, CloneChar:GetDescendants() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end
    for _,Parts in next, DeadChar:GetDescendants() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
con = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
    resetBindable:Destroy()
    pcall(function()
        game.Players.LocalPlayer.Character = DeadChar
        DeadChar.Humanoid.Health = 0
        DeadChar.Head:Destroy()
        game.Players.LocalPlayer.Character = CloneChar
        CloneChar:Destroy()
    end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
                game.Players.LocalPlayer.Character = DeadChar
                DeadChar.Humanoid.Health = 0
                DeadChar.Head:Destroy()
                game.Players.LocalPlayer.Character = CloneChar
                CloneChar:Destroy()
            end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()

SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

local function hattp(hat1,rig,pos,rot)
    coroutine.wrap(function()
        hat1.CFrame = rig.CFrame * (pos or CFrame.new(0,0,0)) * (rot or CFrame.Angles(0,0,0))
    end)()
end
local function bptp(bp,rig)
    coroutine.wrap(function()
        bp.Position = rig.CFrame.p
    end)()
end
local function newbp()
    local bp = Instance.new("BodyPosition")
    bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
    bp.P = 100000000
    return bp
end
local function newbg()
    local bp = Instance.new("BodyGyro")
    bp.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bp.P = 100000000
    return bp
end

newbp().Parent = DeadChar["Torso"]
newbg().Parent = DeadChar["Torso"]
coroutine.wrap(function()
    local hatp
    function httpto()
        if HumanDied then hatp:Disconnect(); return end
        hattp(DeadChar["Head"],CloneChar["Head"])
        hattp(DeadChar["Torso"],CloneChar["Torso"])
        hattp(DeadChar["Left Arm"],CloneChar["Left Arm"])
        hattp(DeadChar["Right Arm"],CloneChar["Right Arm"])
        hattp(DeadChar["Left Leg"],CloneChar["Left Leg"])
        hattp(DeadChar["Right Leg"],CloneChar["Right Leg"])
        DeadChar["Torso"].BodyPosition.Position = CloneChar["Torso"].CFrame.p
        DeadChar["Torso"].BodyGyro.CFrame = CloneChar["Torso"].CFrame
    end
    hatp = game:GetService("RunService").Stepped:Connect(httpto)
end)()


for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end

DeadChar.Torso["Left Shoulder"]:Destroy()
DeadChar.Torso["Right Shoulder"]:Destroy()
DeadChar.Torso["Left Hip"]:Destroy()
DeadChar.Torso["Right Hip"]:Destroy()

game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

function RUNANIMATESCRIPT(FOLDER)

    local Figure = FOLDER.Parent
    local Torso = Figure:WaitForChild("Torso")
    local RightShoulder = Torso:WaitForChild("Right Shoulder")
    local LeftShoulder = Torso:WaitForChild("Left Shoulder")
    local RightHip = Torso:WaitForChild("Right Hip")
    local LeftHip = Torso:WaitForChild("Left Hip")
    local Neck = Torso:WaitForChild("Neck")
    local Humanoid = Figure:WaitForChild("Humanoid")
    local pose = "Standing"
    
    local currentAnim = ""
    local currentAnimInstance = nil
    local currentAnimTrack = nil
    local currentAnimKeyframeHandler = nil
    local currentAnimSpeed = 1.0
    local animTable = {}
    local animNames = { 
        idle = 	{	
                    { id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
                    { id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
                },
        walk = 	{ 	
                    { id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
                }, 
        run = 	{
                    { id = "run.xml", weight = 10 } 
                }, 
        jump = 	{
                    { id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
                }, 
        fall = 	{
                    { id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
                }, 
        climb = {
                    { id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
                }, 
        sit = 	{
                    { id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
                },	
        toolnone = {
                    { id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
                },
        toolslash = {
                    { id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
    --				{ id = "slash.xml", weight = 10 } 
                },
        toollunge = {
                    { id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
                },
        wave = {
                    { id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
                },
        point = {
                    { id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
                },
        dance1 = {
                    { id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
                },
        dance2 = {
                    { id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
                },
        dance3 = {
                    { id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
                },
        laugh = {
                    { id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
                },
        cheer = {
                    { id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
                },
    }
    local dances = {"dance1", "dance2", "dance3"}
    
    -- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
    local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
    
    function configureAnimationSet(name, fileList)
        if (animTable[name] ~= nil) then
            for _, connection in pairs(animTable[name].connections) do
                connection:disconnect()
            end
        end
        animTable[name] = {}
        animTable[name].count = 0
        animTable[name].totalWeight = 0	
        animTable[name].connections = {}
    
        -- check for config values
        local config = FOLDER:FindFirstChild(name)
        if (config ~= nil) then
    --		print("Loading anims " .. name)
            table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
            table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
            local idx = 1
            for _, childPart in pairs(config:GetChildren()) do
                if (childPart:IsA("Animation")) then
                    table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
                    animTable[name][idx] = {}
                    animTable[name][idx].anim = childPart
                    local weightObject = childPart:FindFirstChild("Weight")
                    if (weightObject == nil) then
                        animTable[name][idx].weight = 1
                    else
                        animTable[name][idx].weight = weightObject.Value
                    end
                    animTable[name].count = animTable[name].count + 1
                    animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
        --			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
                    idx = idx + 1
                end
            end
        end
    
        -- fallback to defaults
        if (animTable[name].count <= 0) then
            for idx, anim in pairs(fileList) do
                animTable[name][idx] = {}
                animTable[name][idx].anim = Instance.new("Animation")
                animTable[name][idx].anim.Name = name
                animTable[name][idx].anim.AnimationId = anim.id
                animTable[name][idx].weight = anim.weight
                animTable[name].count = animTable[name].count + 1
                animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
    --			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
            end
        end
    end
    
    -- Setup animation objects
    function scriptChildModified(child)
        local fileList = animNames[child.Name]
        if (fileList ~= nil) then
            configureAnimationSet(child.Name, fileList)
        end	
    end
    
    FOLDER.ChildAdded:connect(scriptChildModified)
    FOLDER.ChildRemoved:connect(scriptChildModified)
    
    
    for name, fileList in pairs(animNames) do 
        configureAnimationSet(name, fileList)
    end	
    
    -- ANIMATION
    
    -- declarations
    local toolAnim = "None"
    local toolAnimTime = 0
    
    local jumpAnimTime = 0
    local jumpAnimDuration = 0.3
    
    local toolTransitionTime = 0.1
    local fallTransitionTime = 0.3
    local jumpMaxLimbVelocity = 0.75
    
    -- functions
    
    function stopAllAnimations()
        local oldAnim = currentAnim
    
        -- return to idle if finishing an emote
        if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
            oldAnim = "idle"
        end
    
        currentAnim = ""
        currentAnimInstance = nil
        if (currentAnimKeyframeHandler ~= nil) then
            currentAnimKeyframeHandler:disconnect()
        end
    
        if (currentAnimTrack ~= nil) then
            currentAnimTrack:Stop()
            currentAnimTrack:Destroy()
            currentAnimTrack = nil
        end
        return oldAnim
    end
    
    function setAnimationSpeed(speed)
        if speed ~= currentAnimSpeed then
            currentAnimSpeed = speed
            currentAnimTrack:AdjustSpeed(currentAnimSpeed)
        end
    end
    
    function keyFrameReachedFunc(frameName)
        if (frameName == "End") then
    
            local repeatAnim = currentAnim
            -- return to idle if finishing an emote
            if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
                repeatAnim = "idle"
            end
            
            local animSpeed = currentAnimSpeed
            playAnimation(repeatAnim, 0.0, Humanoid)
            setAnimationSpeed(animSpeed)
        end
    end
    
    -- Preload animations
    function playAnimation(animName, transitionTime, humanoid) 
            
        local roll = math.random(1, animTable[animName].totalWeight) 
        local origRoll = roll
        local idx = 1
        while (roll > animTable[animName][idx].weight) do
            roll = roll - animTable[animName][idx].weight
            idx = idx + 1
        end
    --		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
        local anim = animTable[animName][idx].anim
    
        -- switch animation		
        if (anim ~= currentAnimInstance) then
            
            if (currentAnimTrack ~= nil) then
                currentAnimTrack:Stop(transitionTime)
                currentAnimTrack:Destroy()
            end
    
            currentAnimSpeed = 1.0
        
            -- load it to the humanoid; get AnimationTrack
            currentAnimTrack = humanoid:LoadAnimation(anim)
            currentAnimTrack.Priority = Enum.AnimationPriority.Core
                
            -- play the animation
            currentAnimTrack:Play(transitionTime)
            currentAnim = animName
            currentAnimInstance = anim
    
            -- set up keyframe name triggers
            if (currentAnimKeyframeHandler ~= nil) then
                currentAnimKeyframeHandler:disconnect()
            end
            currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
            
        end
    
    end
    
    -------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------
    
    local toolAnimName = ""
    local toolAnimTrack = nil
    local toolAnimInstance = nil
    local currentToolAnimKeyframeHandler = nil
    
    function toolKeyFrameReachedFunc(frameName)
        if (frameName == "End") then
    --		print("Keyframe : ".. frameName)	
            playToolAnimation(toolAnimName, 0.0, Humanoid)
        end
    end
    
    
    function playToolAnimation(animName, transitionTime, humanoid, priority)	 
            
            local roll = math.random(1, animTable[animName].totalWeight) 
            local origRoll = roll
            local idx = 1
            while (roll > animTable[animName][idx].weight) do
                roll = roll - animTable[animName][idx].weight
                idx = idx + 1
            end
    --		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
            local anim = animTable[animName][idx].anim
    
            if (toolAnimInstance ~= anim) then
                
                if (toolAnimTrack ~= nil) then
                    toolAnimTrack:Stop()
                    toolAnimTrack:Destroy()
                    transitionTime = 0
                end
                        
                -- load it to the humanoid; get AnimationTrack
                toolAnimTrack = humanoid:LoadAnimation(anim)
                if priority then
                    toolAnimTrack.Priority = priority
                end
                    
                -- play the animation
                toolAnimTrack:Play(transitionTime)
                toolAnimName = animName
                toolAnimInstance = anim
    
                currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
            end
    end
    
    function stopToolAnimations()
        local oldAnim = toolAnimName
    
        if (currentToolAnimKeyframeHandler ~= nil) then
            currentToolAnimKeyframeHandler:disconnect()
        end
    
        toolAnimName = ""
        toolAnimInstance = nil
        if (toolAnimTrack ~= nil) then
            toolAnimTrack:Stop()
            toolAnimTrack:Destroy()
            toolAnimTrack = nil
        end
    
    
        return oldAnim
    end
    
    -------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------
    
    
    function onRunning(speed)
        if speed > 0.01 then
            playAnimation("walk", 0.1, Humanoid)
            if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
                setAnimationSpeed(speed / 14.5)
            end
            pose = "Running"
        else
            if emoteNames[currentAnim] == nil then
                playAnimation("idle", 0.1, Humanoid)
                pose = "Standing"
            end
        end
    end
    
    function onDied()
        pose = "Dead"
    end
    
    function onJumping()
        playAnimation("jump", 0.1, Humanoid)
        jumpAnimTime = jumpAnimDuration
        pose = "Jumping"
    end
    
    function onClimbing(speed)
        playAnimation("climb", 0.1, Humanoid)
        setAnimationSpeed(speed / 12.0)
        pose = "Climbing"
    end
    
    function onGettingUp()
        pose = "GettingUp"
    end
    
    function onFreeFall()
        if (jumpAnimTime <= 0) then
            playAnimation("fall", fallTransitionTime, Humanoid)
        end
        pose = "FreeFall"
    end
    
    function onFallingDown()
        pose = "FallingDown"
    end
    
    function onSeated()
        pose = "Seated"
    end
    
    function onPlatformStanding()
        pose = "PlatformStanding"
    end
    
    function onSwimming(speed)
        if speed > 0 then
            pose = "Running"
        else
            pose = "Standing"
        end
    end
    
    function getTool()	
        for _, kid in ipairs(Figure:GetChildren()) do
            if kid.className == "Tool" then return kid end
        end
        return nil
    end
    
    function getToolAnim(tool)
        for _, c in ipairs(tool:GetChildren()) do
            if c.Name == "toolanim" and c.className == "StringValue" then
                return c
            end
        end
        return nil
    end
    
    function animateTool()
        
        if (toolAnim == "None") then
            playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
            return
        end
    
        if (toolAnim == "Slash") then
            playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
            return
        end
    
        if (toolAnim == "Lunge") then
            playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
            return
        end
    end
    
    function moveSit()
        RightShoulder.MaxVelocity = 0.15
        LeftShoulder.MaxVelocity = 0.15
        RightShoulder:SetDesiredAngle(3.14 /2)
        LeftShoulder:SetDesiredAngle(-3.14 /2)
        RightHip:SetDesiredAngle(3.14 /2)
        LeftHip:SetDesiredAngle(-3.14 /2)
    end
    
    local lastTick = 0
    
    function move(time)
        local amplitude = 1
        local frequency = 1
            local deltaTime = time - lastTick
            lastTick = time
    
        local climbFudge = 0
        local setAngles = false
    
            if (jumpAnimTime > 0) then
                jumpAnimTime = jumpAnimTime - deltaTime
            end
    
        if (pose == "FreeFall" and jumpAnimTime <= 0) then
            playAnimation("fall", fallTransitionTime, Humanoid)
        elseif (pose == "Seated") then
            playAnimation("sit", 0.5, Humanoid)
            return
        elseif (pose == "Running") then
            playAnimation("walk", 0.1, Humanoid)
        elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
    --		print("Wha " .. pose)
            stopAllAnimations()
            amplitude = 0.1
            frequency = 1
            setAngles = true
        end
    
        if (setAngles) then
            local desiredAngle = amplitude * math.sin(time * frequency)
    
            RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
            LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
            RightHip:SetDesiredAngle(-desiredAngle)
            LeftHip:SetDesiredAngle(-desiredAngle)
        end
    
        -- Tool Animation handling
        local tool = getTool()
        if tool and tool:FindFirstChild("Handle") then
        
            local animStringValueObject = getToolAnim(tool)
    
            if animStringValueObject then
                toolAnim = animStringValueObject.Value
                -- message recieved, delete StringValue
                animStringValueObject.Parent = nil
                toolAnimTime = time + .3
            end
    
            if time > toolAnimTime then
                toolAnimTime = 0
                toolAnim = "None"
            end
    
            animateTool()		
        else
            stopToolAnimations()
            toolAnim = "None"
            toolAnimInstance = nil
            toolAnimTime = 0
        end
    end
    
    
    local events = {}
    local eventHum = Humanoid
    
    local function onUnhook()
        for i = 1, #events do
            events[i]:Disconnect()
        end
        events = {}
    end
    
    local function onHook()
        onUnhook()
        
        pose = eventHum.Sit and "Seated" or "Standing"
        
        events = {
            eventHum.Died:connect(onDied),
            eventHum.Running:connect(onRunning),
            eventHum.Jumping:connect(onJumping),
            eventHum.Climbing:connect(onClimbing),
            eventHum.GettingUp:connect(onGettingUp),
            eventHum.FreeFalling:connect(onFreeFall),
            eventHum.FallingDown:connect(onFallingDown),
            eventHum.Seated:connect(onSeated),
            eventHum.PlatformStanding:connect(onPlatformStanding),
            eventHum.Swimming:connect(onSwimming)
        }
    end
    
    
    onHook()
    --FOLDER:WaitForChild("Loaded").Value = true
    
    
    -- main program
    
    -- initialize to idle
    playAnimation("idle", 0.1, Humanoid)
    pose = "Standing"
    
    spawn(function()
        while Figure.Parent ~= nil do
            local _, time = wait(0.1)
            move(time)
        end
    end)
    
    return {
        onRunning = onRunning, 
        onDied = onDied, 
        onJumping = onJumping, 
        onClimbing = onClimbing, 
        onGettingUp = onGettingUp, 
        onFreeFall = onFreeFall, 
        onFallingDown = onFallingDown, 
        onSeated = onSeated, 
        onPlatformStanding = onPlatformStanding,
        onHook = onHook,
        onUnhook = onUnhook
    }
    
    end
    RUNANIMATESCRIPT(CloneChar.Animate)

elseif cht:match("<LoadSecretCompiledScript>") then

print("Compiling..")
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER
--\\====================================================//--

wait(0.2)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local SC = false

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, DIRECTION * Distance), Ignore)
end

--Debree({Delay = 1.5,Variant = "",Location = Torso.Position,Color = C3(1,1,1),Size = 1,Distance = 1,Material = "Slate",Scatter = 1,Amount = 1,DebreeCount = 1})
function Debree(Table)
	local KindOf = (Table.Variant or "Ring")
	local Position = (Table.Location or Torso.Position)
	local Coloration = (Table.Color or C3(1,1,1))
	local Texture = (Table.Material or "Slate")
	local Fling = (Table.Scatter or 1)
	local Number = (Table.Amount or 1)
	local Rocks = (Table.DebreeCount or 1)
	local Range = (Table.Distance or 1)
	local Scale = (Table.Size or 1)
	local Timer = (Table.Delay or 1.5)
	coroutine.resume(coroutine.create(function()
		local ScaleVector = VT(Scale,Scale,Scale)
		local Boulders = {}
		Position = CF(Position)
		if KindOf == "Ring" or KindOf == "Both" then
			for RockValue = 1, Number do
				local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale/4),math.ceil(Scale/4)),Range)
				local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
				BOULDER.CanCollide = true
				BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				BOULDER.Color = Coloration
				table.insert(Boulders,BOULDER)
			end
		end
		if KindOf == "Loose" or KindOf == "Both" then
			for RockValue = 1, Rocks do
				local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale-(Scale/2)),math.ceil(Scale-(Scale/2))),0.7)
				local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, false)
				BOULDER.CanCollide = true
				BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				BOULDER.Velocity = CF(BOULDER.Position-VT(0,4,0),BOULDER.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,5,0).p).lookVector*MRANDOM(Fling-(Fling/1.5),Fling+(Fling/1.5))
				BOULDER.Color = Coloration
				table.insert(Boulders,BOULDER)
			end
		end
		if KindOf == "Random" then
			for RockValue = 1, Number do
				local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale/4),math.ceil(Scale/4)),MRANDOM(0,Range))
				local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
				BOULDER.CanCollide = true
				BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				BOULDER.Color = Coloration
				table.insert(Boulders,BOULDER)
			end
		end
		wait(Timer)
		for E = 1, 45 do
			Swait()
			for A = 1, #Boulders do
				Boulders[A].Transparency = Boulders[A].Transparency + 1/45
			end
		end
		for A = 1, #Boulders do
			Boulders[A]:Destroy()
		end
	end))
end

--//=================================\\
--||	   MUSIC AND COLORS
--\\=================================//

local BASECOLOR = C3(0,0,0)
local BMUSIC = IT("Sound",RootPart)
local VOLUME = 1
local PITCH = 1
local SONGID = 1442022177
local PLAYING = false
local INTRO = false
local SCREENS = {}
local SCREENWELDS = {}
local GUISTEXT = {}

--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyDamage(Humanoid,Damage)
	if Damage > 0 then
		Damage = Damage * DAMAGEMULTIPLIER
		if Humanoid.Health < 2000 then
			if Humanoid.Health - Damage > 0 then
				Humanoid.Health = Humanoid.Health - Damage
			else
				Humanoid.Parent:BreakJoints()
			end
		else
			Humanoid.Parent:BreakJoints()
		end
	end
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

local GLASSESWLD = nil
function IntroThing()
	ATTACK = true
	Rooted = true
	RootJoint.C0 = CF(0,250,0)
	CONNECT = Mouse.KeyDown:connect(function(NEWKEY)
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		if HITFLOOR then
			CONNECT:Disconnect()
			local SOUND = CreateSound(606241996, Effects, 5, 1)
			coroutine.resume(coroutine.create(function()
				repeat Swait() SOUND.Parent = Effects until SOUND.Playing == false
				PLAYING = true
			end))
			for i=0, 0.4, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.31, -0.65 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(60), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -1.4) * ANGLES(RAD(65), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.1 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(60), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i = 1, 3 do
				WACKYEFFECT({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(HITPOS) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,1,1), SoundID = 765590102, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 5, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			end
			Debree({Delay = 4,Variant = "Ring",Location = HITPOS,Color = HITFLOOR.Color,Size = 3,Distance = 15,Material = HITFLOOR.Material,Scatter = 1,Amount = 30,DebreeCount = 8})
			for i=0, 0.85, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.31, -0.65 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(60), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -1.4) * ANGLES(RAD(65), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.1 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(60), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 1, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.31, -0.65 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(60), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-50 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -1.4) * ANGLES(RAD(65), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.1 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(60), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 1, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, 0.7) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local GLASSES = CreatePart(3, Character, "Fabric", 0, 0, BRICKC("Pearl"), "Glasses", VT(0,0,0), false)
			CreateMesh("SpecialMesh", GLASSES, "FileMesh", "1577360", "1577349", VT(1, 1.3, 1), VT(0,0,0))
			local HELDWELD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, GLASSES, CF(0,-1.4,0) * ANGLES(RAD(90), RAD(0), RAD(180)), CF(0,0,0))
			CreateSound(147722227, GLASSES, 2, 1.3, false)
			for i=0, 0.25, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45), RAD(0), RAD(-35)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.45, -0.1) * ANGLES(RAD(30), RAD(-5), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 0.3, 0.1 / Animation_Speed do
				Swait()
				HELDWELD.C1 = Clerp(HELDWELD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(-35)), 0.1)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.2, -0.8) * ANGLES(RAD(160), RAD(-5), RAD(-46)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.15, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			HELDWELD.Part0 = Head
			HELDWELD.Parent = Head
			HELDWELD.C0 = CF(0,0.1,-0.15)
			HELDWELD.C1 = CF(0,0,0)
			for i = 1, 3 do
				for i=0, 0.4, 0.1 / Animation_Speed do
					Swait()
					HELDWELD.C1 = Clerp(HELDWELD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(-5)), 0.25)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.2, -0.3) * ANGLES(RAD(160), RAD(-5), RAD(-12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.4, 0.1 / Animation_Speed do
					Swait()
					HELDWELD.C1 = Clerp(HELDWELD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(5)), 0.25)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.1, -0.3) * ANGLES(RAD(160), RAD(-5), RAD(-12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.2, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
			for i = 1, 4 do
				Swait()
				local SCREEN = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Cyan"), "SCREEN", VT(2.5,0.8,0)*2, false)
				local SCREENWELD = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, SCREEN, CF(0,0,0) * ANGLES(RAD(0),RAD((360/6)*i),RAD(0)) * CF(0,0,3+(i/1.5)), CF(0,0,0))
				table.insert(SCREENS,SCREEN)
				table.insert(SCREENWELDS,SCREENWELD)
				local GUI = IT("SurfaceGui",SCREEN)
				for i = 1, 5 do
					local SCREENFRAME = CreateFrame(GUI, 1, 2, UD2(0, 0, ((1/5)*i)-1/5, 0), UD2(1, 0, 1/5, 0), C3(0,0,0), C3(0,0,0), "TESTING.exe")
					local TEXT = CreateLabel(SCREENFRAME, "[BOOTING UP...]", C3(1,1,1), Enum.FontSize.Size48, "Code", 0.5, 1, 1, "RunningTests")
					TEXT.TextXAlignment = "Left"
					TEXT.TextWrapped = true
					table.insert(GUISTEXT,TEXT)
				end
			end
			for i=0, 1, 0.1 / Animation_Speed do
				Swait()
				HELDWELD.C1 = Clerp(HELDWELD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)), 0.4)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15, -0.25) * ANGLES(RAD(160), RAD(-5), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.15, -0.25) * ANGLES(RAD(160), RAD(5), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 0.1, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-5), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			GLASSESWLD = HELDWELD
			ATTACK = false
			Rooted = false
		end
	end)
end
function Screening(Text,FinishesMoveEnd,WaitTillFinished)
	local SCREEN = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Cyan"), "SCREEN", VT(2.5,0.8,0)*1.5, false)
	local SCREENWELD = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, SCREEN, CF(0,0,0) * ANGLES(RAD(-12),RAD(180),RAD(0)) * CF(0,0,1.5), CF(0,0,0))
	local GUI = IT("SurfaceGui",SCREEN)
	local SCREENFRAME = CreateFrame(GUI, 1, 2, UD2(0, 0, 0, 0), UD2(1, 0, 1, 0), C3(0,0,0), C3(0,0,0), "TESTING.exe")
	local TEXT = CreateLabel(SCREENFRAME, Text, C3(1,1,1), Enum.FontSize.Size48, "Code", 0.5, 1, 1, "RunningTests")
	TEXT.TextScaled = true
	coroutine.resume(coroutine.create(function()
		coroutine.resume(coroutine.create(function()
			for i = 1, 5 do
				Swait()
				SCREEN.Transparency = SCREEN.Transparency - 0.1/5
			end
		end))
		if WaitTillFinished == false then
			for i=0, 1.7, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.45 + 0.1 * COS(SINE / 12), -0.2) * ANGLES(RAD(45), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif WaitTillFinished == true then
			repeat
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.45 + 0.1 * COS(SINE / 12), -0.2) * ANGLES(RAD(45), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until ATTACK == false
		end
		coroutine.resume(coroutine.create(function()
			SCREENWELD:Remove()
			SCREEN.Anchored = true
			for i = 1, 5 do
				Swait()
				SCREEN.Transparency = SCREEN.Transparency + 0.1/5
			end
			SCREEN:Remove()
		end))
		if FinishesMoveEnd == true then
			ATTACK = false
			Rooted = false
		end
	end))
	return SCREEN,TEXT
end
local Fling = function()
	ATTACK = true
	Rooted = false
	Screening(";Fling",true,false)
	wait(0.25)
	RightShoulder.C0 = RightShoulder.C0 * CF(0,-0.12,0)
	CreateSound(138204323, RightArm, 2, 1.3, false)
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	if HITFLOOR then
		Debree({Delay = 4,Variant = "Ring",Location = HITPOS,Color = HITFLOOR.Color,Size = 4,Distance = 75,Material = HITFLOOR.Material,Scatter = 1,Amount = MRANDOM(75,85),DebreeCount = 8})
	end
	ApplyAoE(RootPart.Position-VT(0,4,0),75,5,12,550,false)
	WACKYEFFECT({Time = 35, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(150,150,150), Transparency = 0.75, Transparency2 = 1, CFrame = CF(RootPart.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 610359590, SoundPitch = 1, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
end
local TpTo = function()
	ATTACK = true
	Rooted = true
	local SCR, TEXT = Screening("",false,true)
	for i = 1, 35 do
		Swait()
		local TPSPOT = "TPTO: ["..math.ceil(Mouse.Hit.p.X).."."..math.ceil(Mouse.Hit.p.Y+3.15).."."..math.ceil(Mouse.Hit.p.Z).."]"
		TEXT.Text = TPSPOT
	end
	RightShoulder.C0 = RightShoulder.C0 * CF(0,-0.12,0)
	CreateSound(138204323, RightArm, 2, 1.3, false)
	CreateSound(1127492102, Torso, 2, 1, false)
	RootPart.CFrame = CF(Mouse.Hit.p+VT(0,3.15,0)) * ANGLES(RAD(0), RAD(RootPart.Orientation.Y), RAD(0))
	wait(0.1)
	ATTACK = false
	Rooted = false
end
local Hurl = function()
	ATTACK = true
	Rooted = false
	local SCREEN = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Cyan"), "SCREEN", VT(2.5,0.8,0)*1.5, false)
	local SCREENWELD = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, SCREEN, CF(0,0,0) * ANGLES(RAD(-12),RAD(180),RAD(0)) * CF(0,0,1.5), CF(0,0,0))
	local GUI = IT("SurfaceGui",SCREEN)
	local SCREENFRAME = CreateFrame(GUI, 1, 2, UD2(0, 0, 0, 0), UD2(1, 0, 1, 0), C3(0,0,0), C3(0,0,0), "TESTING.exe")
	local TEXT = CreateLabel(SCREENFRAME, "[COLLECTING DEBREE]", C3(1,1,1), Enum.FontSize.Size48, "Code", 0.5, 1, 1, "RunningTests")
	local ROCKS = {}
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			SCREEN.Transparency = SCREEN.Transparency - 0.1/5
		end
	end))
	for i = 1, 12 do
		local SPOT = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0)) * CF(0,0,MRANDOM(4,15))
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		if HITFLOOR then
			coroutine.resume(coroutine.create(function()
				local BOULDER = CreatePart(3, Effects, HITFLOOR.Material, 0, 0, BRICKC("Cyan"), "Debree", VT(1,1,1)*(MRANDOM(5,25)/10), true)
				BOULDER.Color = HITFLOOR.Color
				BOULDER.CFrame = CF(HITPOS-VT(0,5,0)) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0))
				local CFRAME = SPOT*CF(0,MRANDOM(7,12),0)
				table.insert(ROCKS,BOULDER)
				for i = 1, 35 do
					Swait()
					BOULDER.CFrame = Clerp(BOULDER.CFrame,CFRAME,0.1)
				end
			end))
		end
	end
	for i=0, 1.7, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.75 + 0.1 * COS(SINE / 12), -0.1) * ANGLES(RAD(145), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if #ROCKS > 0 then
		TEXT.Text = "[HURLING DEBREE]"
		local GYRO = IT("BodyGyro",RootPart)
		GYRO.D = 2
		GYRO.P = 20000
		GYRO.MaxTorque = VT(0,4000000,0)
		GYRO.CFrame = CF(RootPart.Position,Mouse.Hit.p)
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(RootPart.Position,Mouse.Hit.p)
			until ATTACK == false
			GYRO:Remove()
		end))
		local THROWING = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(25)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 7 * COS(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.45 + 0.1 * COS(SINE / 12), -0.2) * ANGLES(RAD(90), RAD(0), RAD(25)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.3, 0.45 + 0.1 * COS(SINE / 12), -0.2) * ANGLES(RAD(44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(25)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(50), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until THROWING == false
		end))
		for E = 1, #ROCKS do
			wait(0.05)
			local ROCK = ROCKS[E]
			coroutine.resume(coroutine.create(function()
				ROCK.CFrame = CF(ROCK.Position,Mouse.Hit.p)
				CreateSound(147722227, ROCK, 2, 1.3, false)
				local KILL = false
				for i = 1, 70 do
					Swait()
					for i = 1, 4 do
						ROCK.CFrame = ROCK.CFrame * CF(0,0,-ROCK.Size.Z/2)
						local HIT,POS,NORMAL = Raycast(ROCK.Position,ROCK.CFrame.lookVector,ROCK.Size.Z/1.5,Character)
						if HIT then
							KILL = true
							CreateSound(174580476, ROCK, 2, 1.6, false)
							ApplyAoE(ROCK.Position,6*ROCK.Size.Z,25,35,12,false)
							for E = 1, 2 do
								for i = 1, 4 do
									WACKYEFFECT({Time = 50, EffectType = "Round Slash", Size = VT(0,0,0), Size2 = (VT(E,0,E)/15)*ROCK.Size.Z, Transparency = 0.8, Transparency2 = 1, CFrame = CF(ROCK.Position) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
								end
							end
							Debree({Delay = 0.8,Variant = "Loose",Location = ROCK.Position,Color = ROCK.Color,Size = ROCK.Size.Z/3,Distance = 75,Material = ROCK.Material,Scatter = 35,Amount = MRANDOM(75,85),DebreeCount = 8})
							break
						else
							WACKYEFFECT({Time = 6, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(3,1,3)*ROCK.Size.Z, Transparency = 0.97, Transparency2 = 1, CFrame = ROCK.CFrame*CF(0,0,-ROCK.Size.Z/2) * ANGLES(RAD(90), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = MRANDOM(-1,1), RotationY = MRANDOM(-1,1), RotationZ = MRANDOM(-1,1), Material = "Neon", Color = BRICKC"Cyan".Color, SoundID = nil, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 5, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 25})
						end
					end
					if KILL == true then
						break
					end
				end
				ROCK.Transparency = 1
				Debris:AddItem(ROCK,5)
			end))
			wait(0.05)
		end
		THROWING = false
	end
	coroutine.resume(coroutine.create(function()
		SCREENWELD:Remove()
		SCREEN.Anchored = true
		for i = 1, 5 do
			Swait()
			SCREEN.Transparency = SCREEN.Transparency + 0.1/5
		end
		SCREEN:Remove()
	end))
	ATTACK = false
	Rooted = false
end
local Kill = function()
	local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = HUM.Parent:FindFirstChild("HumanoidRootPart") or HUM.Parent:FindFirstChild("Torso")
			if ROOT and HUM.Health > 0 then
				local FOE = ROOT.Parent
				ATTACK = true
				Rooted = false
				Screening(";Kill",true,false)
				wait(0.25)
				RightShoulder.C0 = RightShoulder.C0 * CF(0,-0.12,0)
				CreateSound(138204323, RightArm, 2, 1.3, false)
				for index, CHILD in pairs(FOE:GetChildren()) do
					if CHILD:IsA("BasePart") then
						if CHILD.Name == "Head" then
							WACKYEFFECT({Time = MRANDOM(10,30), EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)*2, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 50})
						elseif CHILD.Name ~= "HumanoidRootPart" then
							WACKYEFFECT({Time = MRANDOM(10,30), EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size*2, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 35})
						end
					end
				end
				FOE:BreakJoints()
			end
		end
	end
end
local ATTAC = function()
	ATTACK = true
	Rooted = false
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-5), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end
local LITTLEIDLE = false
function UniqueIdleAnimation()
	coroutine.resume(coroutine.create(function()
		for i=0, 0.1, 0.1 / Animation_Speed do
			Swait()
			if ATTACK == true or ANIM ~= "Idle" then
				break
			end
			GLASSESWLD.C1 = Clerp(GLASSESWLD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)), 0.25)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(80), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if ATTACK == true or ANIM ~= "Idle" then
				break
			end
			GLASSESWLD.C1 = Clerp(GLASSESWLD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)), 0.25)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 1.3, 0.1 / Animation_Speed do
			Swait()
			if ATTACK == true or ANIM ~= "Idle" then
				break
			end
			GLASSESWLD.C1 = Clerp(GLASSESWLD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(5)), 0.2 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.15, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			if ATTACK == true or ANIM ~= "Idle" then
				break
			end
			GLASSESWLD.C1 = Clerp(GLASSESWLD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.05, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.1, 0.1 / Animation_Speed do
			Swait()
			if ATTACK == true or ANIM ~= "Idle" then
				break
			end
			GLASSESWLD.C1 = Clerp(GLASSESWLD.C1, CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)), 0.25)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(80), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		LITTLEIDLE = false
	end))
end

--//=================================\\
--||	     GUIS AND KEYS
--\\=================================//

local COLOR = C3(1,1,1)
local SKILLFONT = "Legacy"
local SIZE = 2.5
local MOUSE = 2097542191
local MELEE = 2097543015
local BODY = 2097543382
local PROJECTILE = 2097544084
local AOE = 2097544884
local ULTIMATE = 2097545381

local ATTACKS = {{"Switch ScreenBehaviour","m"},{";Fling","z",AOE,Fling},{";TpTo","x",BODY,TpTo},{";Hurl","c",PROJECTILE,Hurl},{";Kill","v",MOUSE,Kill}}
local GUIS = {}

for i = 1, #ATTACKS do
	local SKILLFRAME = CreateFrame(WEAPONGUI, 0.8, 2, UD2(1-(0.3*(SIZE/5)), 0, 1-((0.08*(SIZE/5))*i), 0), UD2(0.3*(SIZE/5), 0, 0.06*(SIZE/4), 0), C3(0,0,0), COLOR, "Skill Frame")
	local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i][1].."]", COLOR, SIZE, SKILLFONT, 0, 2, 0, "Skill text")
	SKILLTEXT.TextXAlignment = "Right"
	local BUTTONDISPLAY = CreateLabel(SKILLFRAME, "["..string.upper(ATTACKS[i][2]).."]", COLOR, SIZE-1, SKILLFONT, 0, 2, 0, "Skill text")
	BUTTONDISPLAY.TextXAlignment = "Left"
	if ATTACKS[i][3] then
		local IMAGETODISPLAY = IT("ImageLabel",SKILLFRAME)
		IMAGETODISPLAY.Image = "rbxassetid://"..ATTACKS[i][3]
		IMAGETODISPLAY.Size = UD2(0.2,0,1,0)
		IMAGETODISPLAY.Position = UD2(0.065,0,0,0)
		IMAGETODISPLAY.BackgroundTransparency = 1
		IMAGETODISPLAY.ZIndex = 0
	end
	table.insert(GUIS,SKILLTEXT)
end

Mouse.Button1Down:connect(function(NEWKEY)
	
end)
Mouse.Button1Up:connect(function(NEWKEY)
	
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KEYHOLD = true
	if NEWKEY == "m" then
		if SC == false then
			SC = true
		else
			SC = false
		end
	end
	if ATTACK == false then
		for E = 1, #ATTACKS do
			if ATTACKS[E][4] ~= nil then
				if NEWKEY == ATTACKS[E][2] then
					ATTACKS[E][4]()
				end
			end
		end
	end
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KEYHOLD = false
end)

--//=================================\\
--\\=================================//

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local MOVINGSCREENS = false
local TIMESTAMP = 0
while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	ANIMATOR.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 8 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0.1 * COS(SINE / (WALKSPEEDVALUE/2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.25 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10+50 * COS(SINE / WALKSPEEDVALUE))), 0.6 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.25 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10+50 * COS(SINE / WALKSPEEDVALUE))), 0.6 / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
			if MRANDOM(1,650) == 1 and LITTLEIDLE == false then
				LITTLEIDLE = true
				UniqueIdleAnimation()
			end
			if LITTLEIDLE == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(3 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(5), RAD(0), RAD(-7 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(7 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(-5), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(5), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
		end
	end
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("Accessory") then
			if c.Name == "Nerd Glasses" then
				c:Destroy()
			end
		end
	end
	unanchor()
	Humanoid.MaxHealth = 1e3
	Humanoid.Health = 1e3
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	BMUSIC.SoundId = "rbxassetid://"..SONGID
	BMUSIC.Looped = true
	BMUSIC.Pitch = PITCH
	BMUSIC.Volume = VOLUME
	BMUSIC.Playing = PLAYING
	BMUSIC.EmitterSize = 50
	if BMUSIC.Parent ~= RootPart then
		print("Fixing music")
		BMUSIC = IT("Sound",RootPart)
		BMUSIC.SoundId = "rbxassetid://"..SONGID
		BMUSIC.Looped = true
		BMUSIC.Pitch = PITCH
		BMUSIC.Volume = VOLUME
		BMUSIC.Playing = true
		BMUSIC.EmitterSize = 50
		BMUSIC.TimePosition = TIMESTAMP
		FIXING = true
	else
		if FIXING == false then
			TIMESTAMP = BMUSIC.TimePosition
		else
			FIXING = false
		end
	end
	if Head:FindFirstChild("face") then
		Head.face.Texture = "rbxassetid://62682458"
	end
	Humanoid.Name = "ADMIN"
	if INTRO == false and ATTACK == false then
		INTRO = true
		coroutine.resume(coroutine.create(function()
			IntroThing()
		end))
	end
	if #SCREENS > 0 then
		for E = 1, #SCREENS do
			SCREENS[E].Transparency = MRANDOM(90,99)/100
		end
	end
	if #SCREENWELDS > 0 then
		if SC == true then
			if MRANDOM(1,75) == 1 and MOVINGSCREENS == false then
				MOVINGSCREENS = true
				coroutine.resume(coroutine.create(function()
					wait(1)
					MOVINGSCREENS = false
				end))
				for E = 1, #SCREENWELDS do
					coroutine.resume(coroutine.create(function()
						local MATH1 = MRANDOM(-25,25)/10+1
						local MATH2 = MRANDOM(-45,45)
						for i = 1, 55 do
							Swait()
							SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,MATH1,0) * ANGLES(RAD(0), RAD(MATH2+180), RAD(0)) * CF(0,0,3+(E/1.5)),0.1)
						end
					end))
				end
			end
		elseif SC == false then
			for E = 1, #SCREENWELDS do
				if E == 1 then
					SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,-1 + 0.05 * COS(SINE / 12),0) * ANGLES(RAD(0), RAD(-40+180), RAD(0)) * CF(0,0,3.4),0.1)
				elseif E == 2 then
					SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,-1 + 0.05 * SIN(SINE / 12),0) * ANGLES(RAD(0), RAD(40+180), RAD(0)) * CF(0,0,3.4),0.1)
				elseif E == 3 then
					SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,1.3 + 0.05 * SIN(SINE / 12),0) * ANGLES(RAD(0), RAD(-38+180), RAD(0)) * CF(0,0,3.4),0.1)
				elseif E == 4 then
					SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,1.3 + 0.05 * COS(SINE / 12),0) * ANGLES(RAD(0), RAD(38+180), RAD(0)) * CF(0,0,3.4),0.1)
				end
			end
		end
	end
	local SECONDS = math.floor(workspace.DistributedGameTime)
	local MINUTES = math.floor(workspace.DistributedGameTime/60)
	local HOURS = math.floor(workspace.DistributedGameTime/60/60)
	local SECONDS = SECONDS - (MINUTES * 60)
	local MINUTES = MINUTES - (HOURS * 60)
	if #GUISTEXT > 0 then
		for E = 1, #GUISTEXT do
			local TXT = GUISTEXT[E]
			if E == 1 then
				TXT.Text = "SERVER STATS;"
			elseif E == 2 then
				TXT.Text = "SERVER TIME = ["..SECONDS..":"..MINUTES..":"..HOURS.."]"
			elseif E == 3 then
				TXT.Text = "WORKSPACE GRAVITY = ["..workspace.Gravity.."]"
			elseif E == 4 then
				TXT.Text = "SERVER JOBID = ["..game.JobId.."]"
			elseif E == 5 then
				TXT.Text = "SERVER VERSION = ["..game.PlaceVersion.."]"
			end
		end
	end
	local SPACEJECTS = {}
	for index, CHILD in pairs(workspace:GetChildren()) do
		table.insert(SPACEJECTS,CHILD)
	end
	table.insert(SPACEJECTS,game.Lighting)
	table.insert(SPACEJECTS,game.Workspace)
	local MALWARE = {"BlurEffect","BloomEffect","Fire","ParticleEmitter","Smoke"}
	if #GUISTEXT > 0 then
		if MRANDOM(1,125) == 1 then
			for E = 1, #GUISTEXT do
				local TXT = GUISTEXT[E]
				local TEXT = ""
				local DOINGS = {"MONITORING","CHECKING"}
				local OLDTEXT = string.sub(TXT.Text,3)
				if E > 5 then
					if E <= 15 then
						if MRANDOM(1,3) == 1 then
							repeat
								local MONITORME = SPACEJECTS[MRANDOM(1,#SPACEJECTS)]
								if MRANDOM(1,2) == 1 then
									TEXT = DOINGS[MRANDOM(1,#DOINGS)].."; ["..MONITORME.Name.."]..."
									for Z = 1, #MALWARE do
										if MONITORME:FindFirstChildOfClass(MALWARE[Z]) then
											TEXT = "!FOUND MALICIOUS CONTENT IN ["..MONITORME.Name.."]; FOUND: ["..MALWARE[Z].."]"
											if TEXT ~= OLDTEXT then
												CreateSound(136075117, TXT.Parent.Parent, 0.6, MRANDOM(8,12)/10)
											end
											TXT.TextColor3 = C3(1,0,0)
											break
										else
											TXT.TextColor3 = C3(1,1,1)
										end
									end
									break
								end
								if MRANDOM(1,6) == 1 and TXT.TextColor3 == C3(1,1,1) then
									local ES = {"SUCCES.","!FAILURE!"}
									TEXT = "TESTING FILE #"..MRANDOM(100,999).." ["..ES[MRANDOM(1,#ES)].."]"
								end
							until TEXT ~= ""
							local DESIREDTEXT = ">>"..TEXT
							TXT.Text = DESIREDTEXT
						end
					elseif E > 15 then
						local N = E-15
						local POP = 0
						repeat
							for index, CHILD in pairs(game:GetService("Players"):GetChildren()) do
								POP = POP + 1
								if POP == N then
									TEXT = "MONITORING USER; ".."["..CHILD.Name.."]..."
									break
								else
									TEXT = "NOP"
								end
							end
						until TEXT ~= ""
						if TEXT ~= "NOP" then
							local DESIREDTEXT = ">>"..TEXT
							TXT.Text = DESIREDTEXT
						else
							TXT.Text = ""
						end
					end
				end
			end
		end
	end
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--

elseif cht:match("<load hacker x>") then


wait(0.2)

local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('Hacker Loaded')
local mouse = plr:GetMouse()
local char = plr.Character
local hum = char:FindFirstChildOfClass'Humanoid'
local hed = char.Head
local root = char:FindFirstChild'HumanoidRootPart'
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Lime green")
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
    local wld = Instance.new("Weld", wp1)
    wld.Part0 = wp0
    wld.Part1 = wp1
    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end
newWeld(tors, ll, -0.5, -1, 0)
ll.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(tors, rl, 0.5, -1, 0)
rl.Weld.C1 = CFrame.new(0, 1, 0)
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
			local lerp = function(a, b, t)
	return a * (1 - t) + b * t
end
	
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game.Players:GetPlayerFromCharacter(script.Parent),
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(0, 1, 0))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							--[[local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://294291785"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new(1,0)
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)]]
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.03
								end
								wait(0.5)
								--PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function FindNearestTorso(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Torso") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
Effects = {
	Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("BlockMesh",p)
	m.Scale = meshstart
	coroutine.wrap(function()
		for i = 0, 1, factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
			if spin == true then
				p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			end
		end
		p:Destroy()
	end)()
return p
	end,
	Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("SpecialMesh",p)
	m.MeshType = "Sphere"
	m.Scale = meshstart
	coroutine.wrap(function()
		for i=0,1,factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
		end
	p:Destroy()
end)()
return p
	end,

	Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("CylinderMesh",p)
	m.Scale = meshstart
	coroutine.wrap(function()
		for i=0,1,factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
		end
	p:Destroy()
end)()
return p
	end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CamShake(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
function Smooth(Part)
	Part.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	Part.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	Part.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
	Part.RightSurface = Enum.SurfaceType.SmoothNoOutlines
	Part.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
	Part.BackSurface = Enum.SurfaceType.SmoothNoOutlines
end
hum.MaxHealth = 1.0E298
hum.Health = 1.0E298
game:GetService("RunService"):BindToRenderStep("HOT", 0, function()
  if hum.Health > 0.1 and hum.Health < 1.0E298 then
    hum.MaxHealth = 1.0E298
    hum.Health = 1.0E298
  end
end)
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
--------------------------------------------------------------------    --------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 2007066385
if plr.Name == "KillerDarkness0105" then
    SONG = 1837185092
    
    
    
  for _, v in pairs(char:GetDescendants()) do
        if v.ClassName == "Part" and v.Name ~= "Head" and v.Name ~= "LeftArm" and v.Name ~= "RightArm" then
            v.Material = "Neon"
            v.Color = Color3.new(0,0,0)
            if v:FindFirstChildOfClass("SpecialMesh") then
                v:FindFirstChildOfClass("SpecialMesh").TextureId = ""
            end
            end
    end
    
    
    end
if plr.Name == "InfiniteOneWithdank" then
	SONG = 200602561
end
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local WasAir = false
local InAir = false
local LandTick = 0
local movelegs = false
local FF = Instance.new("ForceField",char)
FF.Visible = false
local Speed = 16
local Screen = true
local op1 = false
local Sitt = false




--Wuss poppin B)
local RightCP = [[   

_./Index- Start/Code_TrackerV2.Exe/AdminStart



>Loading Code Tracker V2.

...


...


...

>BOOT_FINSHED STARTING CODETRACKERV2//



>Code Tracker V2 Loaded.



>Insert credentials
>Login: LOGIN
>Password: PASSWORD



...



Login: Codex47
Password: **************


>Processing...

...

...

>_INDEX IPLOOKUP/LOAD/IP/193.281.74.39

>PASSWORDCHECK - SUCCESSFUL

>Welcome Codex. Remember Help for basic commands, SHelp for admin commands.



Help

>LOADING

...


...


>PROCESSING FINSHED


>LOADING COMMANDS

// WINDOW COMMANDS \\


>ASSOC          Displays or modifies file extension associations.
ATTRIB         Displays or changes file attributes.
BREAK          Sets or clears extended CTRL+C checking.
BCDEDIT        Sets properties in boot database to control boot loading.
CACLS          Displays or modifies access control lists (ACLs) of files.
CALL           Calls one batch program from another.
CHKNTFS        Displays or modifies the checking of disk at boot time.
CLS            Clears the screen.
CMD            Starts a new instance of the Windows command interpreter.
COLOR          Sets the default console foreground and background colors.
COMP           Compares the contents of two files or sets of files.
COMPACT        Displays or alters the compression of files on NTFS partitions.
CONVERT        Converts FAT volumes to NTFS.  You cannot convert the
               current drive.
COPY           Copies one or more files to another location.
DATE           Displays or sets the date.
DEL            Deletes one or more files.
DIR            Displays a list of files and subdirectories in a directory.
FC             Compares two files or sets of files, and displays the
LABEL          Creates, changes, or deletes the volume label of a disk.
MD             Creates a directory.
MKDIR          Creates a directory.
MKLINK         Creates Symbolic Links and Hard Links
MODE           Configures a system device.
MORE           Displays output one screen at a time.
MOVE           Moves one or more files from one directory to another
               directory.
OPENFILES      Displays files opened by remote users for a file share.
PATH           Displays or sets a search path for executable files.
PAUSE          Suspends processing of a batch file and displays a message.
RECOVER        Recovers readable information from a bad or defective disk.
TASKKILL       Kill or stop a running process or application.
TIME           Displays or sets the system time.
TITLE          Sets the window title for a CMD.EXE session.
TREE           Graphically displays the directory structure of a drive or
               path.
TYPE           Displays the contents of a text file.
VER            Displays the Windows version.
VERIFY         Tells Windows whether to verify that your files are written
               correctly to a disk.
VOL            Displays a disk volume label and serial number.
XCOPY          Copies files and directory trees.
WMIC           Displays WMI information inside interactive command shell.


// IP COMMANDS \\


GRAB           Grabs randomly generated IP's for VPN use.
IP           	 Displays your current IP address.
DDOS           Stresses the IP using data packets and bandwidth overloaders.
FIRE           Protects users IP by firing a automatic disconnect if bandwidth reaches a certain level.
PULL           Pulls data packets from other networks for faster network sending and download data.


For more information on tools see th-

You : Shut up.


Load: Code Terminal

//ACCESSING HIDDEN COMMAND DATA 010101011101110011101\\

>LOAD PROCESS_INDEX?/C0DEXTERMINAL

>INSERT DOWNLOAD FILE CONSTRAINT

CODETERM/FILE/19853/DOWNLOAD.org

>SUCCESSFUL CONSTRAINT

>LOADING TERMINAL




...


...


...


...



...


>Boot Failed.


...


>RESTARTPROCESS/CODETERM.EXE/LOAD

...



>Restarting Code Terminal.

>Getting Information Please Wait.....
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 

>Code Terminal Loaded.
>Welcome ...
>You're not Cod-


>Getting Information Please Wait.....
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 

00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 

00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 


So, Trying to break into my program huh?

Well You got another thing coming to you bud.
Those passwords, this entire program, It was all an elaborate scam.
And you, Being the pathetic little wannabe hacker kid, fell right for it.
Now i think you have an even bigger problem.
Hell you even gave me your own ip by using the IPLOOKUP function.
Well may god help you.
Because im coming for you now kid.
See ya soon.
REMOTEWRITTEN/FILEDELETESYSTEM/SYS32

You:Looks Like I Gotta Restore Everything That Damned Codex.

>Deleting System32.










...











.....










......






>System32 Deleted. Initate System Restore.




...






....





...



>System Restored.
>Welcome NEWUSER

>Getting Information Please Wait.....
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 

You: I Know Your There Codex.

Codex: You'd be surely mistaken kid. Im coming for you. Also by the way, here's your private ip. --[193.281.74.39]--

You: Did You Know When You Try To Get My IP It Actually Shows Yours.

Codex: Oh Shit...

Monitor Closed.
   ]]



local idlecp = [[

  <--  BEGINNING DELETION SEQUENCE  -->
>Please note, unknown things may occur as you're going through others files.

>Deletion Beginning.
01101001 01101011 10000000 01110010 11111111 11010001 10111101 00010001 
11111000 00111010 01100010 10000001 11011111 10000011 00010001 00010000 
00100000 01111001 01111100 10110010 11110000 10000101 00101100 00000011 
10010111 01011011 10000010 11110110 01010010 00101101 11010101 10010000 
01001100 00101011 10101111 01101001 10100111 01000101 00110011 11001110 
10010110 10111011 11110111 00111110 11111010 01100101 11110100 01011011 
00111101 10001110 11001010 10010000 10110001 11110100 11101111 00011000 
00000000 01110110 10101101 00100000 11001010 00111000 10011101 00110010 
00110100 00010101 01101010 10101010 10011001 10011101 11000001 10111100 
10110001 11011101 11010100 11111010 11101100 01111100 00000001 01101100 
10010100 00010001 10100110 10110010 01101000 01110000 11111001 11100110 
00100100 10010100 00001100 01111011 01101010 00000011 01100110 01111100 
11010111 00101111 11110000 00101010 00110101 10110000 10100101 00100101 
11110100 01011110 00000100 01000100 11101101 00100101 00000110 01100010 
01110010 00111011 11001100 00000000 11101001 11100000 00111000 00010001 
11101001 11000101 00111000 01110000 11110000 10000100 11000001 11011001 
01001001 11010001 10111001 01101110 10100000 00101001 10100110 01111100 
11101001 11100101 01011110 01010001 11010000 10001000 11010110 01101101 
11111000 01100100 10111100 01001000 01001111 01100001 00100101 00001110 
11101110 01010011 10111000 11001011 10011011 00000010 01110010 11010011 
11011000 10101110 01000110 01010110 11000111 10110001 11111010 01111010 
01010011 10010110 00100100 00110100 01110001 10001110 10010110 00101111 
>KillerDarkness0105 Account Deletion.exe Active
00000010 01110000 01101111 10110010 10111001 10001010 10111000 11000001 
00010111 11111010 00100010 10001100 11011111 10010101 11001010 00000010 
10101101 01100011 00000010 11111101 00101000 11000100 11101111 10111101 
>Account Successfully Deleted.
00000001 00000000 10011100 10000001 01110001 01001110 00100000 00000001 
10000101 11011101 11011000 01011110 01100100 00010000 11110100 10000001 
01110101 01011111 11011111 01111010 11111010 10010101 10111111 00011100 
00010100 11000111 00100111 00100010 01010100 01010000 11101011 01101110 
10100001 10111000 11001011 00010010 10001110 01110011 00110111 10001100 
11111011 01110010 00100110 01101001 11011101 00010011 10000101 01001001 
11010110 01000000 00110111 01111101 10011010 00110001 11110001 00110101 
10011111 11111110 00100101 00011100 01010010 01010111 11100000 10111111 
00100101 10001111 01011110 11000100 10111110 00110111 00000100 11010110 
11010101 11011000 11010011 11010111 11111001 11001010 10011100 00010111 
>Account Successfully Deleted
01111110 10100101 11110100 00011000 11110101 11101101 01111001 11110011 
01010101 11000000 10001000 10001100 11110010 00011000 10111101 11111100 
01010110 10101100 01101011 01000111 01001111 00010100 00010110 11101110 
01011001 00010110 10111011 01111110 11111001 01101000 11001110 10000011 
01010101 10010111 10110010 00100011 00100010 00011010 10000101 00011110 
01110011 10111110 00000101 10110111 01101101 10001111 10000010 11100000 
01001011 11111111 11111100 00100010 11101101 10010000 01011110 00111111 
11010001 10110000 11101101 01101100 10000111 10100111 11110010 11010000 
00100110 01101011 01001100 00010110 10000000 10000111 11100000 11101011 
>FuntimeArtic Account Deletion.exe Active
11000011 10001111 01111011 00011001 11011011 01010001 01010101 11101101 
>Error
>Unable To Read Data.
01101001 01101011 10000000 01110010 11111111 11010001 10111101 00010001 
11111000 00111010 01100010 10000001 11011111 10000011 00010001 00010000 
00100000 01111001 01111100 10110010 11110000 10000101 00101100 00000011 
10010111 01011011 10000010 11110110 01010010 00101101 11010101 10010000 
01001100 00101011 10101111 01101001 10100111 01000101 00110011 11001110 
10010110 10111011 11110111 00111110 11111010 01100101 11110100 01011011 
>Delete TroubleShoot
01101001 01101011 10000000 01110010 11111111 11010001 10111101 00010001 
11111000 00111010 01100010 10000001 11011111 10000011 00010001 00010000 
00100000 01111001 01111100 10110010 11110000 10000101 00101100 00000011 
10010111 01011011 10000010 11110110 01010010 00101101 11010101 10010000 
01001100 00101011 10101111 01101001 10100111 01000101 00110011 11001110 
10010110 10111011 11110111 00111110 11111010 01100101 11110100 01011011 
>Deletion Success
10111110 11001100 00110011 01111100 11111110 00100100 01011101 10100010 
00101011 10110001 10000010 01100110 01110001 10100110 00011011 00000000 
01111111 01001110 00001101 10001100 10110110 01001010 01011101 01010011 
01000110 01100010 00101101 11010110 00100010 00111000 11100000 10010000 
01000010 10001010 11010101 00010010 00110100 00101000 01000111 01101101 
01101011 10011111 00011110 10111100 00100010 00011100 10110110 10000001 
11110111 00111100 10101001 11001111 11001001 01011101 11110100 10101111 
10001100 01111101 11000010 10100111 10001110 11011100 11011111 11101110 
11101001 11001000 10000101 10100100 01110100 00110100 00001111 11001110 
00000001 10111100 00010101 01111010 01110111 00001001 01010011 00110111 
01111100 11101100 00000101 10111011 10011000 01001010 10101100 10100110 
00000011 00000010 11001110 01010010 10101010 01011110 00000101 00100100 
11010001 00101110 00111010 01000000 00110001 01101111 11100100 11100100 
10101110 00000100 11110110 00001101 01100100 00011110 00100010 00110011 
10011000 01101001 10001100 11101111 01110111 00100111 00000001 10100110 
11001111 00101111 10110110 10001000 10011010 10100100 10100100 01110111 
>MonolithicDivinity Account Deletion.exe Active
00000010 01110000 01101111 10110010 10111001 10001010 10111000 11000001 
00010111 11111010 00100010 10001100 11011111 10010101 11001010 00000010 
10101101 01100011 00000010 11111101 00101000 11000100 11101111 10111101 
>Account Successfully Deleted.
00000001 00000000 10011100 10000001 01110001 01001110 00100000 00000001 
10000101 11011101 11011000 01011110 01100100 00010000 11110100 10000001 
01110101 01011111 11011111 01111010 11111010 10010101 10111111 00011100 
00010100 11000111 00100111 00100010 01010100 01010000 11101011 01101110 
10100001 10111000 11001011 00010010 10001110 01110011 00110111 10001100 
11111011 01110010 00100110 01101001 11011101 00010011 10000101 01001001 
10001000 00010010 10011100 11100100 01101011 00110111 00111001 00001110 
01100010 10010111 01010010 00000111 00000001 10011100 00000001 11100111 
00001110 01010110 11011000 10100011 01011101 01111101 00000000 10110101 
01111001 00110001 00001111 01010010 11111011 01010100 11000011 11111110 
01100010 10100111 01010100 11100011 10000100 00111110 11010001 00000111 
01000111 01101001 10111010 00100111 00111000 00101110 10101111 00011100 
01111100 11000100 11010011 00101100 01110010 01001011 10010010 00000000 
10000000 11100000 10101011 11010111 00010000 01000001 10001010 11000000 
11010000 00101010 00001111 10100000 00000000 10001000 00010101 10110001 
10101001 01011111 10001100 00110101 01010000 10011000 10011111 10100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111 
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
>Nebula_Zorua Account Deletion.exe Active...
>Error Unable To Find Account.
>Restarting...
>Unable To Restart.
>Unknown Chat Detected.
>Enter? Y/N
>Y
>Connecting To Chat....
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111 
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
Connected - 4
>You : What the hell kind of technology is this...

>The Broken Angel : You're close my little hacker, but still so far.

>Zelphix : You'll have to try harder.

>You : Who in the hell are you two.

>The Broken Angel & Zelphix : Destroyed figures.

>You : What about your "other friend" in here?

>Nᴉl : ˙sn oʇ sƃuolǝq plɹoʍ sᴉɥ┴
˙noʎ ɹoɟ ƃuᴉɯoɔ ǝɹ,ǝʍ ʇnq
˙˙˙ǝɯ puɐʇsɹǝpun oʇ ǝlqɐ ǝq ʇ,uoʍ ʎlɹɐǝlɔ no⅄

>You : Upside Down Text Ok Fine I Wont TroubleShoot This One.

10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111 
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 

>Chat Disconnected

>You : Damnit.

11110110 00101010 00011001 00100111 01111011 00101111 01001001 10100001 
11101111 01111001 11011000 10000001 01000100 10011111 10110010 10001011 
00000101 01101011 00001010 10011001 11011101 00010010 11000011 11110011 
01100011 01110010 00100000 00001110 10001100 00101010 10001011 00100010 
10011111 10001000 10001010 10110111 11011111 01001101 00011101 00101101 
11011111 10110001 10101111 01101110 11000010 01001000 00010110 00101101 
11111111 10000011 10010001 10110100 11000101 10111000 01111011 10101000 
01011011 11101110 01101001 00101111 11110101 11011000 01111111 01000110 
01111110 11110100 10010010 00011110 11011010 00110000 00100011 10011100 
01000001 10000111 11001101 01100101 01111110 11101010 11110100 00101010 
11010100 00001001 11110010 11110010 11111011 10111101 11100110 11001001 
11001100 11101100 10110111 11100010 10000111 01110010 11100110 00010111 
10010101 11110101 10100001 00110000 10101010 00011010 00001111 11110110 
01001111 10101001 10010011 10111101 00001100 10100000 01100101 01000000 
10111000 11001101 11111001 00000100 01110111 10001100 01001101 11000011 
00111010 00101010 10100110 01100101 01010010 11111010 11000011 10111110 
01000100 00001011 11101100 11000100 01101010 01101011 00111001 01000101 
01100010 10010100 00101001 11001001 11011111 01100111 11000100 00101000 
00100001 11110011 11100000 01100010 10010010 00101000 11011111 11110011 
00011011 01011110 00111101 01101110 01011101 01000010 01011110 10100101 
01100001 01010000 10001100 11100101 10010100 10011001 11010000 10001100 
10110110 00000111 01000000 11111111 00000110 10110100 11011001 01001110 
01101011 11100011 11011101 10111000 11001011 01101111 01010101 10011001 
10111000 11110001 00110101 11010011 01001011 01000010 01001100 10110010 
00101011 01101011 10101100 11100100 10001011 10000111 00110101 10101000 
01001111 00000101 01010101 01101101 01010010 00101011 01000101 00101011 
01100010 01000110 10111110 10001001 11100100 10101101 10111110 10001111 
00101000 10111001 10001101 11100111 11100000 01111100 10000111 10101010 
11011000 10011101 01011010 00101001 01010100 01101111 10101011 00010001 
10100100 00101111 00110000 01011011 00111011 00001011 00100110 00100000 
11111100 01101111 10001100 11011101 11011100 10111110 00110110 01000000 
11000100 11000110 01111001 11101010 01111101 10110011 11101011 10011111 
10111001 00110010 00100110 11111001 11110101 11101100 10100111 01010000 
00111010 11000111 01001001 01010011 00100110 01000111 11000111 01000100 
00100101 00100001 01100100 00111010 11100000 01100101 11110111 10100111 
01001101 10101010 00101110 10100111 11100011 11000100 10100100 01001010 
01100000 00111101 00111101 11100110 00111011 00110101 01001101 10010110 
00011100 10101111 11010101 10100001 10000110 10010001 11101011 01110000 
>Salvo_Starly Account Deletion.exe Active
01100000 00110010 11010001 10001001 10010100 10011010 11010100 00001101 
11111111 00001000 11010011 11100001 00001011 10011110 01000111 11001001 
11110011 11011111 01100001 11001110 10000000 10001101 11101111 00011001 
10011100 11110000 00001100 11011101 00011011 00010110 11110001 01011011 
10000000 10100110 11101111 11111100 11011001 11010010 11111000 01001111 
>Connecting To Furaffinity....
01001111 00110101 01101110 00000001 11011110 01011100 01000100 11011010 
01111000 10110011 01000111 11100110 10100010 00111111 00010010 11011000 
>You : Hold on, WHAT?!
01111101 00101101 11101100 10101101 10001100 11101011 11100111 01110111 
00010111 01101011 01110110 00001111 10101101 01000110 01010111 00000001
10001000 01110100 00110011 10101010 01100100 10111010 01100100 10111010 
>You : Did the account just redirect me to this?!
01100010 11001000 01000100 11101001 11011110 01111110 11010010 11110101 
01111100 10110110 10101110 01000000 00111100 11001110 11000011 01110100 
11100111 11011001 01001001 11010001 10001111 01110101 00001110 00011000 
>Successfully Connected.
>You : Shit..
10001000 01110100 00110011 10101010 01100100 10111010 01100100 10111010 
01100111 01000111 00011101 01111111 01001111 00010101 11010110 11100111 
01100010 11001000 01000100 11101001 11011110 01111110 11010010 11110101 
01111100 10110110 10101110 01000000 00111100 11001110 11000011 01110100 
11100111 11011001 01001001 11010001 10001111 01110101 00001110 00011000 
01101101 10001001 11100010 01000110 00111110 11001010 10001010 10001010 
00011001 10110010 00010110 11011100 11100110 10001001 11010011 10110111 
11101100 11110001 01000110 01110101 00111011 01111000 10111010 01100011 
>delta1035 Account Deletion.exe Active
10010010 10011100 00000110 11000101 00111100 00010100 10001110 01000111 
00001101 01101011 11001011 01110101 01000011 01101010 10111000 00100110 
>Error Line 531 - "What a shitty hacker you are my friend."
00000110 10111001 10001110 10110111 11011011 10101000 11000111 10010110 
10111000 11011000 11010101 01000101 11101010 01111111 11100110 01010011
>Error Proccessed

>Error Found

>Error Executed And Fixed

>Deletion Successful
01010110 11010100 01000110 11100100 11110111 11001110 11111000 00010101 
10111111 01110100 10011011 11101110 01001101 01010011 01000100 10110100 
01111011 11000011 10110110 01100011 11111011 11000011 01000101 01010111 
01011100 10101101 11001010 10110000 11101101 10000101 10000110 00100111 
11010101 10101010 10101001 00001011 11101000 01101000 01011011 11011111 
00001001 10000011 11110001 10010111 01111111 01010010 00001100 01000000 
01111100 11001000 00010010 00101000 11111100 00111110 00000100 11100011 
01111100 00010100 10010010 00111001 01111011 00010000 11100111 01110110 
11111011 01011100 01100100 01110100 11110101 11110100 11001000 10100100 
>Zuu_Roku Account Deletion.exe Active
10000100 10010011 10111001 00000100 11010111 10011000 11001110 11001101 
11000110 10100100 11101011 11111011 11001001 01100111 10011001 11100010 
>Error
10111101 00100000 11111101 01011000 11001101 00111000 10111110 10001010 
00111111 01000000 11111100 11000001 00010100 11001000 01000001 11100001 
10011011 00000001 10010110 10101111 10101100 11000000 00110101 00110000 
00110010 00001001 01110100 10010010 00101001 01010001 01011110 11011110 
>Unable To Detect Password.
01101110 11010011 10100110 11100101 10111000 11101101 01000011 01011000 
11100011 00100000 10001110 10000001 10100001 10010000 10111110 10100011 
00111101 01101100 01100100 10011111 10100001 11110010 01111011 00000010 
>Reason(s) Found : NANO.EXE
00001001 01111110 01101001 10101101 10001100 01001111 01110001 00110011 
00100011 01110001 01000000 00110101 11011000 11101000 10010111 01010001
>NANO Executed
01000101 10110110 10010000 00111011 10010010 11101000 11001001 10010111 
00100111 11000110 10100010 01010011 10111010 11000010 01110111 00101110 
>Deletion Successful
01011101 11110010 10010001 01001001 01011100 11110110 10000001 11110010 
10011010 11011101 11011111 01100111 10001011 00111001 00110010 11010001 
01011000 01110100 00011100 11011011 00000100 11000110 11111011 10000001 
01101001 11011100 11100111 11110001 01001101 01111000 11110101 00101111 
11001101 11011100 01010110 10100011 01111000 00010100 00001101 01100001 
01111100 11110110 10100001 10111111 11001110 10101000 11100010 11011011 
11110111 01110110 01001011 11111111 00011111 11001100 00101101 10110010 
00000010 10010110 11110000 01110011 11110111 00101111 10110111 01011101 
01001001 01111111 10001101 00100000 10110010 01110111 00110111 11010111 
00101101 10110101 00001000 10011110 10001100 00110001 10100001 00001010 
01101100 11110001 11001000 01101000 01000110 00001001 10100101 01111100 
10110110 01010110 00110100 10110111 10000001 00110011 01110100 00011010 
10011011 00011010 10011110 00001111 01111111 10000100 00011100 10100011 
11000010 00010011 11010000 10000111 00111110 01000000 00001100 11101100 
10100100 01111111 11110101 10001010 00000000 10100001 11111110 00101000 
11011110 00110101 00101110 00101000 10110101 00111100 11100011 00000001 
01011100 11010101 10110010 01101101 10110000 10101100 00111110 11011101 
01110011 01011111 00011010 00010010 11010100 11100011 11111111 10100011 
11100000 00000000 11001110 10110110 00110101 10110010 01101000 10011000 
01111101 10110000 11011011 00100100 00100110 00111011 10101111 10100001 
10101001 10001010 11001000 10011001 10001100 10000011 11000000 00101100 
10111101 10101011 11100011 01000111 01100000 10001000 11111110 10111111 
01100011 10111010 00010111 10010101 10001000 00001011 01101101 10110010 
10001001 11111101 11011100 01111101 10011111 11000000 01111100 10100110 
00001110 10101010 00101100 11000110 11001000 11110011 11101111 11100010 
00110101 00000110 11001110 10110011 10010001 10100011 00001000 10010110 
00100110 01110101 11000010 00101010 00011100 01011111 00000001 01110101 
00100111 11110101 10000011 01100110 11000000 01100001 11010011 11001001 
01010101 11101101 10011001 11100111 01000111 00111011 01101001 01011010 
11110001 00000011 11100011 10110010 11010100 00100101 01111011 01001100 
10010101 01111101 11000011 00011111 10100001 00011110 00001010 01010100 
10100000 00101100 11011111 11111011 11101110 01000110 10110111 01110001 
10100111 00110010 01011100 10101100 11101000 10011011 11100101 00110010 
11000100 00111000 00100011 01101001 11001010 01111011 11010101 11110100 
01011100 00111111 01010000 11010000 01010111 00010101 01110101 11110100 
10100000 11111100 01010101 11011011 00010111 10101011 01010000 10011000 
10110100 00100100 01100111 00100101 11110011 10000101 01010011 11110110 
00111001 10011001 10011000 01001111 11110011 11111100 10010011 11011010 
01110110 11001010 01010100 10000100 11111001 00100010 10010010 00011110 
01111101 11001100 01110100 11011000 01110101 11011111 10110111 10001001 
00000111 00000001 11100101 10010101 11111100 10111001 11010111 11110100 
11010101 00001101 01111100 10011001 01110101 10010101 10111110 10111111 
01011110 01010110 10101001 10000101 11000001 11111100 00101100 01010111 
01111010 01110110 01101111 10010010 10001110 00101011 00101001 11101101 
11011011 01110101 11000010 10110100 10110010 11101011 00011110 00010111 
10111000 01010001 10010100 01011001 00100111 00100011 00110111 10011101 
00011101 10001101 01111100 00001000 01001101 11011001 00111101 10011001 
11010100 01110111 00001010 10010110 00100000 10010101 01011100 01001000 
11101011 10110111 01110011 10011110 01110110 11110111 01001000 11011011 
00110100 00101001 10100011 11101000 00010011 01111000 10001010 11010110 
11000011 01100111 10011110 10100000 10111100 00011100 00101101 10111010 
10110110 01100001 10001111 10101010 00000010 10100001 01001111 01001011 
01000111 11110010 01100110 00101110 11101100 11001100 10100000 00100011 
00100101 01010011 11000100 01010001 01101110 01000100 01000110 10000101 
00111011 11000101 11101110 11000111 00110001 11101000 00000011 00010100 
10001001 01111110 01011000 11100000 00011110 11110101 01110001 10010100 
01110001 11011011 11111101 00011000 11100110 01011100 00011000 10001011 
10001001 11101111 00010111 00010011 10111111 01011000 00110111 10101110 
01001110 00010000 01010001 00000001 00110110 01000000 11010001 11111000 
01000001 00111011 11101100 10011111 10001001 10010111 10000100 00111011 
01101110 11101101 01101011 00100110 10011000 00111110 11010100 11011111 
01001100 10101110 01010011 00100100 00110010 11011010 11011111 01000101 
00100001 11111001 10110000 01001111 00010111 00111100 11011100 01011000 
10000100 01110000 00011011 00001001 11111110 10101001 10111001 00000100 
01001010 11110111 01110011 10011101 00010000 00111111 00010101 01110001 
10111100 11001111 11010000 11110110 11100100 11011010 00110101 10110111 
01011110 00011110 01010100 11010100 01011010 10100110 10111111 11101101 
11001010 01100101 11110010 00111011 01000010 01100010 10101001 00000010 
11000001 00101011 00111101 01100101 00100100 10011001 00100100 10000010 
10000110 01100101 10111001 10110110 00010011 10100000 01100101 10001001 
11100001 11101001 11010100 00101100 11001110 00001001 10001000 00010111 
01110010 01101110 01001011 01001000 00111111 01011000 01110101 00111011 
00010111 00010000 00110111 11111000 11011100 10101000 10111111 10110011 
00001111 10000110 10010011 00101110 10001100 11011101 11000101 11000010 
10011010 11100000 10110101 01000100 01001100 10101110 00111110 10111110 
10000010 11111010 01001101 01001110 11100101 11000011 00011010 00100101 
10000011 11101111 01011101 00010011 10111101 00100000 00101001 10011100 
01101001 01001001 00010001 01000011 11001111 01010000 00100010 11101011 
01110101 11000101 00000110 11011011 01101110 10001100 11010001 00100010 
01010101 00010000 11001001 10000110 00001011 00010110 11100000 00100110 
10010000 11010110 01001010 10101111 11101100 11011100 11110110 00111100 
10001010 00100011 00000011 11001011 11001101 01001001 00001010 00000100 
00111010 11010101 01010011 11111011 00100101 11100011 11100100 10000111 
11011100 01110011 10111011 00011001 10001111 11101010 10100110 11111100 
00101111 00001100 11101101 00010000 00100010 11000010 11111010 01000010 
10111001 01110111 10110101 00111100 01101110 11101111 11000011 11101101 
10101000 00001100 11000011 01010110 01010000 11101000 00001001 00101000 
10110110 00001010 11111111 01111001 11010000 00110100 10000101 11110100 
11011001 10110111 01110001 11101111 10110000 10011111 00101010 11111100 
01011010 10001111 01101011 10101000 10111010 10011111 11101001 00101100 
11011100 10010011 01010100 00000001 00110000 10100100 10011111 00101101 
11010101 11000101 01110101 00001011 11101001 00111101 01000010 00001011 
00100110 00010111 01101100 11001100 00000001 00111100 01000101 01101100 
00110001 01010111 00101010 10001111 10000111 11001100 11101101 01011000 
01100101 11100001 00010000 00000001 10101100 11000100 01000001 11111000 
10101101 11000101 10000010 11111000 10110111 00001111 00110011 10101100 
01010100 00010010 01001111 00011111 01010000 11011001 11100110 11101001 
00001010 10110010 11101000 01110100 10010010 10100000 00110111 10010010 
10000101 10010100 10000111 01111010 01010110 10110101 10011000 10101001 
10010101 00110000 10001010 11000111 10010000 00101001 01010001 11010110 
10111000 01111011 11011011 00001000 10000011 00010100 01010000 01011000 
10010100 10011010 01100010 11010111 00000001 01111110 11110001 10011101 
11100001 11011010 11000110 00110110 10100010 10101001 01011001 11001010 
00110001 01110111 10101010 11000111 10111000 11101001 11001100 01101010 
00010001 00110010 11101001 01001110 10000000 01101001 00001011 00111100 
00000000 00110010 10010011 11110000 10000100 11000101 11011000 01000111 
01000100 10000010 01101010 11000000 10000110 01111111 10110111 10011010 
11101100 10101110 01010001 10010010 11011010 10111110 00001000 01101111 
11011010 11111100 11111110 00100101 10010010 01111111 10011101 01111110 
00110010 10101101 10010111 11011010 01001101 01001100 10010000 00011100 
10001101 01011010 01011000 01001011 11010110 11010111 01001011 10010010 
10011100 10001010 11011000 01101110 10011101 10011101 00101110 01110111 
00111010 10100100 00001011 00001010 10010001 01001101 10110001 11100101 
11000110 11000111 10001001 01101111 01110001 01000111 10100000 01100111 
01101111 01111100 11010001 00001100 01100101 01011000 01011000 01110100 
10100100 11011011 10100010 11010010 00111000 11111001 00110011 10100110 
10110111 00010100 00001011 10011100 00001010 11011101 01100010 01001111 
01111001 10000111 11011100 01001101 00011110 11011011 11010011 10111101 
10101111 10010011 11100000 00110101 11011001 10110011 10001111 01111010 
01110110 10111011 11010011 11110110 00010000 01010101 00110000 10110011 
11101100 11011101 01111111 00101000 00010001 00010001 10010001 01101101 
00100100 11011001 11010010 11100010 10110010 01010011 01111010 10111010 
11000010 10111010 10011000 10100101 00100111 10111001 11010000 10100101 
10001100 10100010 11110110 01100110 01100100 01001000 00001011 11010110 
00110111 00100010 00110000 01111001 00001011 00010000 11111001 10111110 
11110111 00101101 01001110 00001100 10001001 10111010 00010010 10101101 
01110000 00011000 11000001 10101011 01010110 00101011 11001101 10000101 
01101101 01101011 01100011 01110110 01101101 11011000 00011100 10100000 
11110010 00000001 11100001 11100101 01001110 01000100 00110110 10011001 
00010000 11101110 11100110 11010010 01011101 10000000 01100011 11100011 
00011001 00111010 11010011 10000111 00110000 00111100 00110001 00110000 
01100110 11010110 11011010 00101111 11110011 10111110 01001010 11000101 
10010001 01001110 11001000 11000111 10000100 00011000 11001110 01001001 
11100001 01011000 10010001 01010010 00000001 01010111 10011011 10010110 
10001111 00000111 11011101 10101010 00111101 11101101 10010001 10110010 
10111011 01110011 10011010 01010000 11110011 00001000 10001010 01110001 
01111001 01011000 00100101 01001001 00011101 11010001 11010111 10000010 
11100000 00001101 00001110 11110011 11100101 01101101 00000000 01011101 
01100110 11010111 10111110 00101011 11111011 01100100 00111011 10110000 
11000010 00011011 01101110 11000110 11011100 11011000 01001100 00011000 
01011001 10000001 00000010 01001101 01001110 01110001 11110100 11001111 
01001001 11111000 00110001 11011111 10100100 00111110 10100101 00000011 
01001100 10100110 01100111 01111110 00010011 01010111 00110001 10011101 
11100000 11010111 01000110 10111110 01110100 01001100 11110110 01010001 
00110101 10100101 01011010 10001011 11001010 11000111 10000010 11110100 
10110101 01110011 11101100 11001011 10000101 01000001 01111001 00010100 
10100011 11000010 00101001 11111010 01011110 00110001 01111000 10001011 
00101100 00110010 10110100 00000001 00100110 00110001 00110111 01010010 
10011111 00010010 10001000 11101100 01101111 10100100 00011011 01011101 
00010101 11000111 01100111 00010101 11000111 10101011 10110110 01101010 
01011011 11111011 00111011 01110010 10101000 10011110 01011000 01101011 
11111010 11100101 01110011 00110011 10000010 00010111 01000010 10010110 
10111110 10111100 10101010 00100011 10111110 00111011 11010000 10010010 
10000000 10110110 01000011 11000000 11000010 01111001 01000001 00100100 
10111111 10001101 11010110 00001100 01010100 00010110 11110000 00000000 
11101000 00001001 00010000 01110010 11111011 10110100 10000001 00000110 
00110101 00101011 00011111 00001000 10001100 00100101 11111110 10011110 
10100111 01101001 00110001 11010101 00011101 10001111 00010110 11111011 
00111111 10000000 10111001 01000000 01111001 01100011 00000110 01010101 
10100111 11101000 11000100 11110010 01001110 00011101 00111010 01110100 
00111000 00010100 11100000 00011110 00110010 01011101 01000100 10010111 
00000101 01110011 00110000 10101110 11111110 11011001 11111110 01101011 
01000100 10100111 01110011 00111100 01011100 10000000 10000110 01110110 
01101101 11011000 01000011 01111000 10111100 00101101 01111111 10110111 
11000010 10000000 11110110 00010101 01000110 01110111 01110101 00001100 
11111010 10101100 11111011 11011110 10000111 00101001 01000001 10001000 
11110010 01101001 00100111 11011001 01000101 00010001 00110111 10110011 
11100000 00010101 10000111 10100100 11101011 00110011 00001011 11000000 
11010011 00011100 01101001 00000110 01101011 10110000 01110011 00110000 
11111011 11000100 01000111 11011101 10100001 11111000 11101010 01111000 
01110000 11001011 11111001 00101100 11000101 10010110 11110100 01110110 
11101000 00100011 11101111 10000110 10010000 01011010 11011111 11110110 
01101010 00111001 00011100 00001100 11100000 10110000 00000111 01000110 
10101100 10101110 01101000 10010110 00101111 00010111 11001100 01101101 
10110011 01001101 01110110 01110110 10111010 00100101 10100000 11011111 
11111010 01101000 00111110 00101100 10001011 00101111 00001011 11010011 
11111101 01010000 01001100 01100001 00100100 10101110 00010000 00001101 
01100001 11010100 10111010 10101010 10111010 01001000 10101000 10100011 
10111001 10100111 10001000 00001011 01100100 11011000 00100000 10010001 
00001011 10011000 01100111 00111001 10010110 11001100 01011001 01010101 
00011101 10110010 10000100 00111111 00010011 10100101 01110001 00100001 
10000001 10011000 00100110 11001111 01101011 01110001 10110001 11100000 
11100110 10010101 00111010 11001101 00101100 11010100 10110100 11010111 
10101001 10001111 00011100 10000000 10000101 01111100 01101001 01011000 
10100100 01010101 10100111 01001010 01001010 10001111 11111100 00001101 
01101010 11000011 00110101 10010110 10000100 01111101 01110011 00110001 
00010111 00101011 00010001 11011011 10100011 10101010 10100001 00000001 
01110010 11101101 00110000 00001001 00111101 11101100 10001100 01001101 
01000001 10111011 10010001 00100110 10001010 00010010 10111000 00000101 
11001011 01100010 10010000 01011011 10100100 11000011 00011011 01010111 
01010101 00010110 11111011 01100110 00100101 10011110 01000110 00111000 
00001010 01110000 00110111 01100000 10010101 01001100 00001110 10000111 
11001001 11111111 11000000 11111100 11101101 00100101 10111110 10011100 
10001100 00100100 10100101 01001001 00100100 11010011 11000001 00100001 
01011100 11110010 00001110 11111110 11011001 10001011 10110000 00001101 
01000011 01110110 11011101 10101000 00111000 11110011 01110010 00110110 
00111101 11110110 10101001 10100010 01111100 01011010 01110000 01011011 
10010101 10100111 00110000 11010011 00001101 00101110 11101011 01110111 
01100101 10010101 00111110 00110000 10110110 00011110 11100010 11111000 
11111111 11110100 11001011 10000011 10000110 10000001 10100000 11110010 
11011101 10101100 01110001 00101001 11111111 00000111 01010001 00100010 
00001011 11001000 00010011 01100100 01011011 11011010 00001011 01000101 
00000000 10001101 11110011 10100010 01000010 00001001 00011011 11010000 
11111001 00011001 10110100 10001001 10010101 01101100 01100111 11100001 
01101001 00001000 10000010 00011011 10100010 00110010 01011010 11110111 
00101110 11010011 01010101 10101011 01010110 11011101 00101011 11101110 
10110011 10001001 11010011 01101011 01111101 10101101 10001101 10000010 
11100010 11011011 11111010 10110110 01110111 00000111 01111101 11101110 
10000111 01011000 11111111 10110010 10111000 10111111 00001000 10001110 
10110000 00011111 00101100 10000010 01010101 00000111 01001110 01001101 
00001001 01011110 00110100 01101000 10100000 11011110 11000010 10111000 
01111100 01110100 00100110 01000001 10011111 01101000 01101010 00000100 
01000001 00111111 00101011 10000010 00110100 00010101 01100001 10100101 
11111001 01100110 10000110 10101111 00010101 00011011 11101010 10011011 
01011010 10011001 10111011 01000010 10001100 11001111 01010011 00111110 
01011010 00011011 11111110 00001101 11101011 10010100 10111101 10111000 
00100001 11101111 01000001 11011111 00001101 00000110 11101000 01010000 
10110100 11000010 11111010 01001101 10101001 01000011 10100010 11000010 
10000011 10010111 11111010 00111011 10110100 11010111 10110010 00101101 
10011101 11100001 11100000 01001110 01001100 01111010 11010101 01001011 
11011001 00111001 01100111 10111010 10110111 00111001 01010001 10110000 
01111010 11110010 10111110 11111011 10001110 10100111 10100110 00111000 
10011110 10100000 10011110 11000111 00111100 10100010 10110111 00010011 
10001011 00011010 10000111 01100011 01110101 01000001 00001011 11110011 
01110111 10000001 11111101 00010100 11001111 00111010 10000010 00110000 
11110100 00001001 10110000 10011001 11010111 10000100 11111110 10001111 
00010111 00010001 10001010 01001011 11100001 01100101 01000000 00000001 
10101010 10100001 00011110 00010011 11010110 11111011 10100000 10111110 
00000110 01111000 11111011 11101001 00110010 00011011 00011010 10001010 
11110100 10110101 01010100 11111000 11100100 00110000 11110111 01101011 
01000000 00111010 00011010 10110111 00001100 10110001 10101001 10001111 
10101100 00000011 00101100 11010010 11101101 00001111 10110001 00110001 
10101011 11001011 10110011 11010010 10010011 10101010 00011111 00010100 
00000111 01010001 01001101 00000110 11001100 10100011 10010110 01001011 
10101010 10100011 00011100 00101110 10001000 01011011 10110101 01000110 
10001100 01110100 00110000 01000000 00011101 11110111 01110010 00000110 
01011111 11001010 00001101 00111000 10101110 10001011 00100001 01101010 
11001110 01010101 11010101 00001100 11001101 00010101 11000010 11010111 
11011101 01100011 00000010 10000101 00011010 00001001 10011010 01010001 
10110110 11110011 00001000 10101010 11101110 11000101 11010011 00101001 
10001100 01110000 01100001 00010001 01011000 10000111 11010001 00101000 
00111010 10001000 01000011 10010100 00011111 01101001 00011101 11000110 
01011101 10111001 01000011 10100010 01000111 01101111 11011101 11011100 
10001010 10101011 01001001 10001100 10111110 00101001 01110010 10000100 
11011101 00011011 00110010 01100111 00111111 01010011 01100101 11100110 
10111011 00001011 01001010 01000101 01011000 00101011 10100100 01110001 
01001111 11000000 11100110 11111110 00100000 10111100 00101000 00011011 
10011000 00010001 11010010 11010011 00101011 11100101 00011011 11111111 
01011011 10010110 11101100 11100111 01010000 00111010 11010101 00100011 
10100101 11100010 01001010 00011110 00011001 01110101 01110011 10011010 
00001001 11011010 01100100 01111101 00101101 11101001 01111010 01011011 
11111111 00001000 01001101 11001001 10111011 01010010 11001001 10011000 
00110001 01110111 11011000 11001001 11001101 10100011 01000010 00000111 
00000110 11111111 01111111 01001011 01101000 11000011 01111101 10000110 
10101001 10001110 01010001 11001110 01100100 10110010 00010011 11101100 
10001000 01011101 01110000 00010110 11000111 00111110 01101111 00111010 
11000111 10111111 10011110 10011001 10001110 01011000 11110101 01101001 
11101101 01001110 01010100 01001010 11100001 01100010 00001100 01101100 
00011101 00100001 10011001 00000101 00111001 00000000 10101100 01111111 
10110000 11010100 00011010 01010011 10100100 01111100 00001100 01010101 
01101010 01000110 00001001 00000111 10100111 11111100 01001010 11111010  
]]

local MainCP = [[
		// Red Mamba Terminal Active \\

--This Is A Very Dangerous Terminal It Is Reccomended To Have Good Protection
-Enter Y/N
-Y

|| Beginning Hyjack Sequence ||

Dekim: This is Not The Best Idea But I Will Let Your Through

You: Thanks.

10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111 
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111  
>Open Place Found: Void Script Builder.exe
>Termination Proccessing
>Error
>Reason(s) Found:Tusk
>Failure: Too fat
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
				Hey There Skid
			It Seems Your Trying To Terminate My Site
			Sorry But I Cannot Allow That
		I Have Injected Your Systems With Malware
			Good Luck C:
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
>Systems Check:Malware Found
>Name:FreeVirus.exe
>Terminated
>Chat Found
>Connect Y/N
>Y
You:Free Virus Huh Thats Not The Best Idea.

Site Holder:Why Is That?

You:I Recoded It Back To You.

Site Holder:Oh GO- 		

>Chat Disconected Due To User Leaving Unexpectedly
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
>Eror-

>RED DEATH.EXE FOUND
>SYS32 DELETED

...

..

.


..


.

>Monitor Restored

>System Restored

You:Well Shit.

11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111 
00001111 10001100 00010011 10101011 10100101 10011010 01111011 00011111 
11110111 00000001 10001000 11000100 01010001 01110001 11111110 00100101 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101010 00011110 00011000 10001100 00001000 01111000 00010100 01101001 
10101101 11111110 11100110 11110000 01011011 11111110 01001101 01101101 
10010100 01011000 00000100 11100111 00011101 10110001 11010100 11100000 
11100000 10010100 01011000 01011011 01000010 11101001 01101010 01100010 
00010100 00101011 00101101 11101010 11001000 00010001 10110101 11111111
11000101 11100000 11100000 10100111 11010100 10000000 10010100 01010001 
11110101 01000010 10000110 01001101 10011110 00111011 01010111 11011000 
11110000 00100101 01011001 01011010 11110001 00010111 11111001 11000010 
10110001 11010101 10110000 10111010 00101110 11010000 10111011 11100001 
00000001 01010101 10111100 00111001 01010010 11010010 01100010 00111101 
11110100 10101100 01010111 00001001 10011111 00011000 01011001 11010101 
00101010 00101011 00111100 11100100 10011000 10011011 00000100 01110111
>Open Proccess Found:

>Roblox.exe

>Terminate Y/N
>Y

Termination Successful

You: Dekim I Think Im Done With The Red Mamba Terminal.

Dekim:Ok I Will Disconect You 

>Red Mamba Terminal Disconeccted			
]]

hum.JumpPower = 55
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
--Origianlly was going to be a screen in the middle :depressed:
local Screen1 = IT("Part")
Screen1.BrickColor = BrickC("Really black")
Screen1.Material = "Glass"
Screen1.Color = Color3.new(0,0,0)
Screen1.Transparency = 0.3
Screen1.Size = Vector3.new(6, 4, 0)
Screen1.CanCollide = false
Screen1.Locked = true
Smooth(Screen1)
local Screen1Weld = IT("Weld")
Screen1Weld.Part0 = root
Screen1Weld.Part1 = Screen1
Screen1Weld.C0 = CF(-0, 3, -5) * angles(0, 0, 0)
Screen1Weld.Parent = Screen1
Screen1.Parent = char

local Screen2 = IT("Part")
Screen2.BrickColor = BrickC("Really black")
Screen2.Material = "Glass"
Screen2.Color = Color3.new(0,0,0)
Screen2.Transparency = 0.3
Screen2.Size = Vector3.new(6, 4, 0)
Screen2.CanCollide = false
Screen2.Locked = true
Smooth(Screen2)
local Screen2Weld = IT("Weld")
Screen2Weld.Part0 = root
Screen2Weld.Part1 = Screen2
Screen2Weld.C0 = CF(8, 4, -2) * angles(0.1, -0.9, 0)
Screen2Weld.Parent = Screen2
Screen2.Parent = char
----------------------------------------------------------------------------------
local Screen3 = IT("Part")
Screen3.BrickColor = BrickC("Really black")
Screen3.Material = "Glass"
Screen3.Color = Color3.new(0,0,0)
Screen3.Transparency = 0.3
Screen3.Size = Vector3.new(6, 4, 0)
Screen3.CanCollide = false
Screen3.Locked = true
Smooth(Screen3)
local Screen3Weld = IT("Weld")
Screen3Weld.Part0 = root
Screen3Weld.Part1 = Screen3
Screen3Weld.C0 = CF(-8, 3, -2) * angles(0.1, 0.9, 0)
Screen3Weld.Parent = Screen3
Screen3.Parent = char
----------------------------------------------------------------------------------
--Credit to Noobygames12 for this Hot gui that I totally stole
local Base = IT("GuiMain")
Base.Parent = plr.PlayerGui
local GUIFrame = IT("Frame")
GUIFrame.Parent = Base
GUIFrame.BackgroundColor3 = Color3.new(255, 255, 255)
GUIFrame.BackgroundTransparency = 1
GUIFrame.BorderColor3 = Color3.new(17, 17, 17)
GUIFrame.Size = UDim2.new(1, 0, 1, 0)
GUIFrame.Position = UDim2.new(0, 0, 0, 0)
local ActualHackerText = Instance.new("TextLabel",GUIFrame)
ActualHackerText.ZIndex = 2
ActualHackerText.Font = "SciFi"
ActualHackerText.BackgroundTransparency = 1
ActualHackerText.BorderSizePixel = 0.65
ActualHackerText.Size = UDim2.new(0.4,0,0.2,0)
ActualHackerText.Position = UDim2.new(0.565, 0, 0.9, 0)
ActualHackerText.TextColor3 = BrickC("Lime green").Color
ActualHackerText.TextStrokeColor3 = BrickC("Really black").Color
ActualHackerText.TextScaled = true
ActualHackerText.TextStrokeTransparency = 0
ActualHackerText.Text = "Hacker X"
ActualHackerText.TextSize = 24
ActualHackerText.Rotation = 1
ActualHackerText.TextXAlignment = "Center"
ActualHackerText.TextYAlignment = "Top"

local FatAssAttacks1 = Instance.new("TextLabel",GUIFrame)
FatAssAttacks1.ZIndex = 2
FatAssAttacks1.Font = "SciFi"
FatAssAttacks1.BackgroundTransparency = 1
FatAssAttacks1.BorderSizePixel = 0.65
FatAssAttacks1.Size = UDim2.new(0.3, 0, 0.1, 0)
FatAssAttacks1.Position = UDim2.new(0.775, 0, 0.7, 0)
FatAssAttacks1.TextColor3 = BrickC("Lime green").Color
FatAssAttacks1.TextStrokeColor3 = BrickC("Really black").Color
FatAssAttacks1.TextScaled = true
FatAssAttacks1.TextStrokeTransparency = 0
FatAssAttacks1.Text = [[
						Q - Relax
						F - Code
						Z - Screen Come / Away
						X - Orbital Strike
						C - EMP
						V - CALAMITY Orb
						]]
FatAssAttacks1.TextSize = 24
FatAssAttacks1.Rotation = 1
FatAssAttacks1.TextXAlignment = "Center"
FatAssAttacks1.TextYAlignment = "Bottom"
-------------------------------------------------------
--End Customization--
-------------------------------------------------------






-------------------------------------------------------
--Start Text Function--
-------------------------------------------------------
function mes(text,texttime)
    if Screen2:FindFirstChild("SurfaceGui")~= nil then
Screen2:FindFirstChild("SurfaceGui"):destroy()
end
local text = text
local SGui = Instance.new("SurfaceGui",Screen2)

SGui.Face = "Back"

SGui.Adornee = Screen2

local hexertextxd = Instance.new("TextBox",SGui)
hexertextxd.Position = UDim2.new(0, 0, 0, 0)
hexertextxd.Size = UDim2.new(0.8, 0, 0.8, 0)
hexertextxd.TextColor3 = Color3.new(0, 1, 0)
hexertextxd.BackgroundTransparency = 1
if Screen == false then
	hexertextxd.TextTransparency = Screen2.Transparency
end
hexertextxd.Font = "Fantasy"
hexertextxd.MultiLine = true
hexertextxd.TextWrapped = true
hexertextxd.TextSize = 34
hexertextxd.TextXAlignment = "Left"
hexertextxd.TextYAlignment = "Top"
hexertextxd.Text = ""
local tm = coroutine.wrap(function()	
for i = 1,string.len(text),1 do
    swait()
	hexertextxd.Text = string.sub(text,texttime,i)
end
wait(3)
for i = 0,6,0.1 do
    swait()
	hexertextxd.TextTransparency = 	hexertextxd.TextTransparency + 0.04
    hexertextxd.Position = UDim2.new(0+0.05*i, 0, 0, 0)
end
SGui:Destroy()
hexertextxd:Destroy()
end)
tm()
end



function mes2(text,texttime)
if Screen3:FindFirstChild("SurfaceGui")~= nil then
	Screen3:FindFirstChild("SurfaceGui"):destroy()
end
local text2 = text
local SGui2 = Instance.new("SurfaceGui",Screen3)
SGui2.Face = "Back"

SGui2.Adornee = Screen3

local hexertextxd2 = Instance.new("TextBox",SGui2)
hexertextxd2.Position = UDim2.new(0, 0, 0, 0)
hexertextxd2.Size = UDim2.new(0.8, 0, 0.8, 0)
hexertextxd2.TextColor3 = Color3.new(0, 1, 0)
hexertextxd2.BackgroundTransparency = 1
hexertextxd2.Font = "Fantasy"
hexertextxd2.MultiLine = true
hexertextxd2.TextWrapped = true
hexertextxd2.TextSize = 34
if Screen == false then
hexertextxd2.TextTransparency = Screen3.Transparency
end
hexertextxd2.TextXAlignment = "Left"
hexertextxd2.TextYAlignment = "Top"
hexertextxd2.Text = "" 
local tm2 =   coroutine.wrap(function()	
for i = 1,string.len(text2),1 do
    swait()
	hexertextxd2.Text = string.sub(text2,1,i)
end
wait(3)
for i = 0,6,0.1 do
    swait()
    hexertextxd2.TextTransparency = 	hexertextxd2.TextTransparency + 0.04
    hexertextxd2.Position = UDim2.new(0+0.05*i, 0, 0, 0)
end
SGui2:Destroy()
hexertextxd2:Destroy()
end)
tm2()
end

function mes3(text,texttime)
    if Screen1:FindFirstChild("SurfaceGui")~= nil then
Screen1:FindFirstChild("SurfaceGui"):destroy()
end
local text3 = text
local SGui3 = Instance.new("SurfaceGui",Screen1)

SGui3.Face = "Back"

SGui3.Adornee = Screen1

local hexertextxd3 = Instance.new("TextBox",SGui3)
hexertextxd3.Position = UDim2.new(0, 0, 0, 0)
hexertextxd3.Size = UDim2.new(0.8, 0, 0.8, 0)
hexertextxd3.TextColor3 = Color3.new(1, 0, 0)
hexertextxd3.BackgroundTransparency = 1
if Screen == false then
	hexertextxd3.TextTransparency = Screen1.Transparency
end
hexertextxd3.Font = "Fantasy"
hexertextxd3.MultiLine = true
hexertextxd3.TextWrapped = true
hexertextxd3.TextSize = 34
hexertextxd3.TextXAlignment = "Left"
hexertextxd3.TextYAlignment = "Top"
hexertextxd3.Text = ""
local tm3 = coroutine.wrap(function()	
for i = 1,string.len(text),1 do
    swait()
	hexertextxd3.Text = string.sub(text,texttime,i)
end
wait(3)
for i = 0,6,0.1 do
    swait()
	hexertextxd3.TextTransparency = 	hexertextxd3.TextTransparency + 0.04
    hexertextxd3.Position = UDim2.new(0+0.05*i, 0, 0, 0)
end
SGui3:Destroy()
hexertextxd3:Destroy()
end)
tm3()
end

-------------------------------------------------------
--End Text Function--
-------------------------------------------------------



-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function AttackTemplate()
	attack = true
	for i = 0, 2, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	attack = false
end
function Maniac()
	Speed = 0
	Cso("1607788178", hed, 3, 0.9)
	attack = true
	for i = 0, 10, 0.1 do
		swait()
		change = 1.5
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 2)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(0)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 2.5 * Sin(sine / 2)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 2) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 2) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Cos(sine / 2)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.1 * Cos(sine / 2)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(0), Rad(55)), 0.1)
	end
	attack = false
	Speed = 16
end
function ScreenAway()
	attack = true
	Speed = 8
	movelegs = true
	for i = 0, 4, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(-55)), 0.1)
	end
  Cso("1184953203", tors, 3, 1)
	for i = 0, 4, 0.1 do
		swait()
		Screen2.Transparency = Screen2.Transparency + 0.03
		Screen3.Transparency = Screen3.Transparency + 0.03
		Screen1.Transparency = Screen1.Transparency + 0.03
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(25)), 0.1)
	end
	Speed = 16
	Screen = false
	movelegs = false
	attack = false
end
function ScreenCome()
	attack = true
	Speed = 8
	movelegs = true
	for i = 0, 4, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(25)), 0.1)
	end
  Cso("1184953775", tors, 3, 1)
	for i = 0, 4, 0.1 do
		swait()
		Screen2.Transparency = Screen2.Transparency - 0.03 
		Screen3.Transparency = Screen3.Transparency - 0.03
		Screen1.Transparency = Screen1.Transparency - 0.03
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(-55)), 0.1)
	end
	Speed = 16
	Screen = true
	movelegs = false
	attack = false
end
function Relax()
	attack = true
	Speed = 0
	Sitt = true
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -1.6 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-15), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(25), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(75), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.3* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(75), Rad(0), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	until Sitt == false
	Speed = 16
	attack = false
end
function Orb_Strike()
	attack = true
	Speed = 12
	movelegs = true
	    
	mes3([[You : Hey Dekim Call In A Orbital Strike	
		
		Dekim : Rekt, Im Always Above You Ya Know.
	
	
	You : Nice job. Keep doing what your doing.
	
	
	Dekim : Alright.
	
	    ]],1.35)
	
	    
	mes2([[You : Bout to rekt some skids.
	
	
	??? : xd we should do this together sometime
	
	
	You : same
	
	    ]],1.35)
	
	mes("Activating: Orbital Air Strike.",0.05)
  	local CombineVoice = Cso("273957502", Screen3, 1, 1)
  		repeat
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(-55)), 0.1)
		until CombineVoice.Playing == false
		attack = false
		Speed = 16
		movelegs = false
		mes("Orbital Air Strike Launched.",0.05)
		coroutine.resume(coroutine.create(function()
    	Cso("2108801154", char, 7, 0.8)
    	for i = 0, 9 do
			Effects.Meshed(mouse.Hit * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),Vector3.new(),Vector3.new(.0115,.0005,.0115),"","rbxassetid://662585058","",0,false,0.03)
			Aura(1, 1.5, "Add", mouse.Hit * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 45, -0.05, maincolor, 0, "Sphere")
			Aura(2, 1.5, "Add", mouse.Hit * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 45, -0.05, maincolor, 0, "Sphere")
		end
		Magic(5, "Add", mouse.Hit * CFrame.new(0, -2.9, 0), Vector3.new(0, 0, 0), 1, maincolor, "Sphere")
		Magic(10, "Add", mouse.Hit * CFrame.new(0, -2.9, 0), Vector3.new(0, 0, 0), 2, maincolor, "Sphere")
		Magic(1, "Add", mouse.Hit, Vector3.new(1, 100000, 1), 0.5, maincolor, "Sphere")
		Magic(1, "Add", mouse.Hit, Vector3.new(1, 1, 1), 0.75, maincolor, "Sphere")
		CamShake(2, 15)
		for i, v in pairs(FindNearestHead(mouse.Hit.p, 24.5)) do
			if v:FindFirstChild("Head") then
				Eviscerate(v)
			end
		end
	end))
end
function Code()
    Sitt = true
    attack = true
    Speed = 0
	Cso("548337197", tors, 7, 1)
    coroutine.resume(coroutine.create(function()
    	for i = 0,2,0.1 do
    	  swait()
    	  Screen2.Transparency = Screen2.Transparency + 0.02
    	  Screen3.Transparency = Screen3.Transparency + 0.02
    	end
    end))
local text = text
local SGui = Instance.new("SurfaceGui",Screen2)
SGui.Face = "Back"
SGui.Adornee = Screen2
local hexertextxd = Instance.new("TextBox",SGui)
hexertextxd.Position = UDim2.new(0, 0, 0, 0)
hexertextxd.Size = UDim2.new(1, 0, 1, 0)
hexertextxd.TextColor3 = Color3.new(0, 1, 0)
hexertextxd.BackgroundTransparency = 1
if Screen == false then
hexertextxd.TextTransparency = Screen2.Transparency
end
hexertextxd.Font = "Code"
hexertextxd.MultiLine = true
hexertextxd.TextWrapped = true
hexertextxd.TextSize = 34
hexertextxd.TextXAlignment = "Center"
hexertextxd.TextYAlignment = "Center"
hexertextxd.Text = ""
local SGui2 = Instance.new("SurfaceGui",Screen3)
SGui2.Face = "Back"
SGui2.Adornee = Screen3
local hexertextxd2 = Instance.new("TextBox",SGui2)
hexertextxd2.Position = UDim2.new(0, 0, 0, 0)
hexertextxd2.Size = UDim2.new(1, 0, 1, 0)
hexertextxd2.TextColor3 = Color3.new(0, 1, 0)
hexertextxd2.TextStrokeColor3 = Color3.new(0,1,0)
hexertextxd2.BackgroundTransparency = 1
hexertextxd2.Font = "Code"
hexertextxd2.MultiLine = true
hexertextxd2.TextWrapped = true
hexertextxd2.TextSize = 34
hexertextxd2.TextTransparency = 0
hexertextxd2.TextXAlignment = "Left"
hexertextxd2.TextYAlignment = "Top"
hexertextxd2.Text =  ""
local SGui3 = Instance.new("SurfaceGui",Screen1)
SGui3.Face = "Back"
SGui3.Adornee = Screen3
local hexertextxd3 = Instance.new("TextBox",SGui3)
hexertextxd3.Position = UDim2.new(0, 0, 0, 0)
hexertextxd3.Size = UDim2.new(1, 0, 1, 0)
hexertextxd3.TextColor3 = Color3.new(0, 1, 0)
hexertextxd3.TextStrokeColor3 = Color3.new(1,0,0)
hexertextxd3.BackgroundTransparency = 1
hexertextxd3.Font = "Code"
hexertextxd3.MultiLine = true
hexertextxd3.TextWrapped = true
hexertextxd3.TextSize = 34
hexertextxd3.TextTransparency = 0
hexertextxd3.TextXAlignment = "Left"
hexertextxd3.TextYAlignment = "Top"
hexertextxd3.Text =  ""
local wordthing = 1
local wordthing2 = 1
local wordthing3 = 1
    while Sitt == true do
        swait()
        if wordthing < #idlecp then
        wordthing = wordthing + 1
        hexertextxd.Text = hexertextxd.Text..RightCP:sub(wordthing2,wordthing2)
        hexertextxd2.Text = hexertextxd2.Text..idlecp:sub(wordthing,wordthing)
		hexertextxd3.Text = hexertextxd2.Text..MainCP:sub(wordthing3,wordthing3)	
        local newline = hexertextxd.Text:find("\n")
		local newline2 = hexertextxd2.Text:find("\n")
		local newline3 = hexertextxd3.Text:find("\n")
		if newline and #hexertextxd.Text > 450 then
		    			hexertextxd.Text = hexertextxd.Text:sub(newline + 1)
		    			end
		if newline2 and #hexertextxd2.Text > 600 then
			hexertextxd2.Text = hexertextxd2.Text:sub(newline2 + 1)
		end
		
		if newline3 and #hexertextxd3.Text > 600 then
			hexertextxd3.Text = hexertextxd3.Text:sub(newline3 + 1)
		end

		if wordthing2 < #RightCP then
		            wordthing2 = wordthing2 + 1 
end
		    
    	else
        wordthing = 1
        end
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(-55)), 0.1)
	end
	for i = 0, 4, 0.1 do
		swait()
    	hexertextxd.TextTransparency = 	hexertextxd.TextTransparency + 0.04
    	hexertextxd.Position = UDim2.new(0, 0, 0-0.05*i, 0)
    	hexertextxd2.TextTransparency = hexertextxd2.TextTransparency + 0.04
    	hexertextxd2.Position = UDim2.new(0+0.05*i, 0, 0, 0)
		hexertextxd3.TextTransparency = hexertextxd3.TextTransparency + 0.04
    	hexertextxd3.Position = UDim2.new(0+0.05*i, 0, 0, 0)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(-40)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(40)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(5 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(10 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(0), Rad(25)), 0.1)
	end
    coroutine.resume(coroutine.create(function()
    for i = 0,2,0.1 do
    	swait()
    	Screen2.Transparency = Screen2.Transparency - 0.02
    	Screen3.Transparency = Screen3.Transparency - 0.02
		Screen1.Transparency = Screen1.Transparency - 0.02
    	end
    end))
    attack = false
    Speed = 16
    wordthing = 1
    wordthing2 = 1
    SGui:Destroy()
    SGui2:Destroy()
end
function EMP()
	attack = true
	Speed = 0
	    
	mes3([[Dekim : Ready to EMP.
	
	
	You : Alright tell me when you're re about to hit it.
	
	
	Dekim : Sure thing.
	
	    ]],1.35)


	    
	mes2([[You : Ya Know EMP's Can Be Pretty Useful.
	
	
	??? : I Know xd
	
	
	You : EMP ACTIVATED!
	
	
	??? : :boi:
	    ]],1.35)
	   
	mes3("EMP Over and out.",1.35)

	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(0)), 0.05)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-3 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(1 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(3 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-1 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0 + 5 * Sin(sine / 20)), Rad(55)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0 - 5 * Sin(sine / 20)), Rad(-55)), 0.1)
	end
	mes([[
		EMP Activated.
		
		
		
		Shatter Before My Command...
	]],.05)
	Magic(5, "Add", root.CFrame * CFrame.new(0, 0, 0), Vector3.new(10, 10, 10), 1, maincolor, "Sphere")
	Magic(3, "Add", root.CFrame * CFrame.new(0, 0, 0), Vector3.new(20, 20, 20), 1, maincolor, "Sphere")
	Magic(1, "Add", root.CFrame * CFrame.new(0, 0, 0), Vector3.new(30, 30, 30), 1, maincolor, "Sphere")
	CamShake(5, 10)
	Cso("285693895", char, 2, 1)
	for i, v in pairs(FindNearestHead(tors.CFrame.p, 44.5)) do
		if v:FindFirstChild("Head") then
			v:FindFirstChildOfClass("Humanoid").PlatformStand = true
			Cso("76047008", v:FindFirstChild("Head"), 7, (math.random(45,155)/150)+0.2)
			Eviscerate(v)
		end
	end
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(0)), 0.1)
		neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-3 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(1 - 1 * Cos(sine / 20))), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(3 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-1 - 1 * Cos(sine / 20))), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0 + 5 * Sin(sine / 20)), Rad(25)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0 - 5 * Sin(sine / 20)), Rad(-25)), 0.1)
	end
	Speed = 16
	attack = false
end
function GLOBAL_PWNAGE()
	attack = true
	Speed = 12
	movelegs = true
	    
	mes3([[NIL : You Wanna know what it feels like to DESTROY EVERYTHING, This Is An Orb of Calamity.
	
	
	You : Oh? Well I Guess I Should Make Use Of it.
	
	
	NIL : IM INJECTING IT NOW!
	
	    ]],1.35)

	    
	mes2([[You : Hey Look Outside
	
	
	??? : WoAH dude thats Pretty Destructive
	
	
	You : This is called a Calamity Orb
	
	
	??? : :thonk:
	    ]],1.35)

	local orb = Instance.new("Part", char)
	orb.Anchored = true
	orb.BrickColor = BrickC("Really red")
	orb.CanCollide = false
	orb.FormFactor = 3
	orb.Name = "Ring"
	orb.Material = "Neon"
	orb.Size = Vector3.new(1, 1, 1)
	orb.Transparency = 0
	orb.TopSurface = 0
	orb.BottomSurface = 0
	local orbm = Instance.new("SpecialMesh", orb)
	orbm.MeshType = "Sphere"
	orbm.Name = "SizeMesh"
	orbm.Scale = Vector3.new(0, 0, 0)
	local scaled = 0.1
	local posid = 0
	for i = 0, 109, 0.1 do
		swait()
		scaled = scaled + 0.001
		posid = posid - scaled
		orb.CFrame = ra.CFrame * CF(0, -0.1 + posid / 1.05, 0)
		orbm.Scale = orbm.Scale + Vector3.new(scaled, scaled, scaled)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-10), Rad(0), Rad(40)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(-40)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(79), Rad(0)) * angles(Rad(-10), Rad(0), Rad(-10)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-79), Rad(0)) * angles(Rad(-15), Rad(0), Rad(10)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(-7.5 * Sin(sine / 20)), Rad(40)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-25), Rad(7.5 * Sin(sine / 20)), Rad(-25)), 0.2)
	end
	coroutine.resume(coroutine.create(function()
		orb.Anchored = false
		--CFuncs.Sound.Create("rbxassetid://260433768", root, 1.25, 1)
		mes("CALAMITY ORB COMING IN EVERYTHING WILL BE DESTROYED",0.05)
		local a = Instance.new("Part", workspace)
		a.Name = "Direction"
		a.Anchored = true
		a.BrickColor = BrickC("Crimson")
		a.Material = "Neon"
		a.Transparency = 1
		a.CanCollide = false
		local ray = Ray.new(orb.CFrame.p, (root.CFrame.lookVector - orb.CFrame.p).unit * 500)
		local ignore = orb
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(0.1, 0.1, 0.1)
		a.CFrame = CF(orb.CFrame.p, position) * CF(0, 0, 0)
		orb.CFrame = a.CFrame
		a:Destroy()
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bv.velocity = orb.CFrame.lookVector * 125
		bv.Parent = orb
		local hitted = false
		game:GetService("Debris"):AddItem(orb, 15)
		wait()
		local hit = orb.Touched:connect(function(hit)
			if hitted == false then
				hitted = true
				coroutine.resume(coroutine.create(function() 
		for i = 0,1.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	end))
				CFuncs.Sound.Create("rbxassetid://151304356", orb, 5, 1)
					for i, v in pairs(FindNearestHead(orb.CFrame.p, 50000)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
				Magic(1, "Add", orb.CFrame, Vector3.new(orbm.Scale.x, orbm.Scale.y, orbm.Scale.z), 1, BrickC("Really black"), "Sphere")
				Magic(2, "Add", orb.CFrame, Vector3.new(orbm.Scale.x, orbm.Scale.y, orbm.Scale.z), 2, BrickC("Really black"), "Sphere")
				for i = 0, 9 do
					--Aura(1, 2.5, "Add", orb.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 5, 5, 50, -0.05, BrickColor.new("Royal purple"), 0, "Sphere")
					--Aura(2, 5, "Add", orb.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 5, 5, 50, -0.05, BrickColor.new("Royal purple"), 0, "Sphere")
				end
				orb.Anchored = true
				orb.Transparency = 1
				wait(8)
				orb:Destroy()
			end
		end)
	end))
	for i = 0, 2, 0.1 do
		swait()
		hum.CameraOffset = Vector3.new(0, -0.2 + 0.1 * Cos(sine / 20), 0)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-5), Rad(0), Rad(40)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(-40)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(79), Rad(0)) * angles(Rad(-10), Rad(0), Rad(-10)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-79), Rad(0)) * angles(Rad(-15), Rad(0), Rad(10)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(45), Rad(-7.5 * Sin(sine / 20)), Rad(40)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-25), Rad(7.5 * Sin(sine / 20)), Rad(-25)), 0.2)
	end
	attack = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
	if (op1 == false and attack == false) or Sitt == true then
		if key == "q" then
			if Sitt == false then
				Relax()
			elseif Sitt == true then
				Sitt = false
			end
		end
	end
	if (op1 == false and attack == false) or Sitt == true then
		if key == "f" then
			if Sitt == false and Screen == true then
				Code()
			elseif Sitt == true then
				Sitt = false
			end
		end
	end
	if attack == false then
		if key == "t" then
			Maniac()
		elseif key == "z" then
			if Screen == true then
				ScreenAway()
			else
				ScreenCome()
			end
		elseif key == "x" then
			Orb_Strike()
			elseif key == "v" then
			GLOBAL_PWNAGE()		
		elseif key == "c" then
			EMP()
		elseif key == "one" then
			SONG = 2007066385
			Music.TimePosition = 0
			mes("Now playing : Welcome to the Game - Main Menu",0.05)
		elseif key == "two" then
			SONG = 1825107283
			Music.TimePosition = 0
			mes("Now playing : Welcome to the Game 2 - Main Menu",0.05)
		elseif key == "three" then
			SONG = 1366716306
			Music.TimePosition = 0
			mes("Now playing : Watashi no mono - School Day Sane",0.05)
		elseif key == "four" then
			SONG = 170282324
		    Music.TimePosition = 0
			Music.Pitch = 0.85
			mes("10001001 00110110 10001011 01101001 01111110 01111101 10111111 10101001 ",0.05)
			mes2("You: What?",0.05)
		elseif key == "five" then
		    SONG = 1837185092
		    Music.TimePosition = 0
			mes("Now playing : (UNKNOWN ARTIST) - Clubbed",0.05)
		elseif key == "six" then
			SONG = 200602561
		    Music.TimePosition = 0
			mes("Now playing : Aldnoah.Zero - SiTE n0w1",0.05)
		end
	end
end)

 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Creterisk and KillerDarkness0105 Third Screen Edit By InfiniteOneWithdank and a move edit aa")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		local Landed = false
		if(hitfloor)then
			WasAir = false
		else
			WasAir = true
		end
		if(WasAir == false)then
			if(InAir == true)then
				LandTick = time()
				Landed = true
			end
		end
		if(time()-LandTick < .3)then
			Landed = true
		end
		if(hitfloor)then
			InAir = false
		else
			InAir = true
		end
		if(not char:FindFirstChildOfClass'Shirt')then
			NewInstance("Shirt",char,{ShirtTemplate='rbxassetid://133708636'})
		else
			char:FindFirstChildOfClass'Shirt'.ShirtTemplate='rbxassetid://133708636'
		end
		if(not char:FindFirstChildOfClass'Pants')then
			NewInstance("Pants",char,{PantsTemplate='rbxassetid://97164626'})
		else
			char:FindFirstChildOfClass'Pants'.PantsTemplate='rbxassetid://97164626'
		end
		local Walking = (math.abs(root.Velocity.x) > 1 or math.abs(root.Velocity.z) > 1)
		local State = (hum.PlatformStand and 'Paralyzed' or hum.Sit and 'Sit' or Landed and 'Land' or not hitfloor and root.Velocity.y < -1 and "Fall" or not hitfloor and root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
		local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
 		Screen3Weld.C1 = clerp(Screen3Weld.C1, CFrame.new(0-0.5*math.cos(sine/40), 0+.82*math.sin(sine/40),0+1.82*math.cos(sine/120))  * CFrame.Angles(math.rad(0+15*math.cos(sine/40)),math.rad(0+7*math.sin(sine/40))+ torvel / 34,math.rad(0+8*math.cos(sine/40))), 0.1)
 		Screen2Weld.C1 = clerp(Screen2Weld.C1, CFrame.new(0+0.5*math.cos(sine/40), 0+.82*math.sin(sine/40),0-1.82*math.cos(sine/120))  * CFrame.Angles(math.rad(0+15*math.cos(sine/40)),math.rad(0-7*math.sin(sine/40))- torvel / 34,math.rad(0+8*math.cos(sine/40))), 0.1)
		Screen1Weld.C1 = clerp(Screen1Weld.C1, CFrame.new(0+0.5*math.cos(sine/40), 0+.82*math.sin(sine/40),0-1.82*math.cos(sine/120))  * CFrame.Angles(math.rad(0+15*math.cos(sine/40)),math.rad(0-7*math.sin(sine/40))- torvel / 34,math.rad(0+8*math.cos(sine/40))), 0.1)
		ActualHackerText.Rotation = 0 - 2 * math.cos(sine / 24)
		ActualHackerText.Position = UDim2.new(0.6, 0 - 10 * math.cos(sine / 32),0.8, 0 - 10 * math.cos(sine / 45))
		if(State == 'Jump')then
			hum.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -.2 - 0.1 * Cos(sine / 20), -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Fall')then
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Land')then
			hum.JumpPower = 0
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(5)), 0.15)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(-5)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(0), Rad(25 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(0), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Idle')then
			change = 0.55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 4 * Sin(sine / 20)), Rad(0 + 1 * Cos(sine / 20)), Rad(0)), 0.1)
				neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) - Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(-3 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(1 - 1 * Cos(sine / 20))), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20) + Rad(0 + 2 * Cos(sine / 20)) * Player_Size, 0* Player_Size) * angles(Rad(0 - 6 * Sin(sine / 20)), Rad(3 + 1 * Cos(sine / 20)), Rad(0)) * angles(Rad(0), Rad(0), Rad(-1 - 1 * Cos(sine / 20))), 0.1)
				RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.1 * Sin(sine / 20)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(0), Rad(55)), 0.1)
			end
		elseif(State == 'Walk')then
			change = 0.76
			hum.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 - 0.15 * Cos(sine / (WALKSPEEDVALUE / 2))) * angles(Rad(10), Rad(0), Rad(0 - 0.75 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / 75), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0 - 0.75 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / 13), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(15), Rad(-55)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0.6* Player_Size) * angles(Rad(-35), Rad(0), Rad(55)), 0.1)
			elseif attack == true and movelegs == true then
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			end
		end
	end
	hum.Name = "HUM"
	hum.WalkSpeed = Speed
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 2
	Music.Parent = tors
	Music.Playing = true
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end


elseif cht:match("<R15 Bypass>") then
HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthPO_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthPO_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = (Position or Vector3.new(0,0,0)) + Part0.CenterOfMass
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AttachmentA,AttachmentB,AlignOri,AttachmentC,AttachmentD}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.ThrottleAdjustTime = math.huge*math.huge
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

warn([==[

Bypass made by Mizt
Thanks for choosing my bypass

]==])
game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",workspace)
fldr.Name = "Bypass by Mizt"
local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = game:FindFirstChildOfClass("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non" 
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		local clonnedhat = v:Clone()
		clonnedhat.Parent = CloneChar
		local hatath = clonnedhat.Handle:FindFirstChildOfClass("Attachment")
		local partath
		for _,v in pairs(CloneChar:GetChildren()) do
			if v:IsA("BasePart") then
				for _,w in pairs(v:GetChildren()) do
					if w.Name == hatath.Name then
						partath = w
						break
					end
				end
				if partath then break end
			end
		end
		local accweld = Instance.new("Weld",clonnedhat.Handle)
		accweld.Name = "AccessoryWeld"
		accweld.Part0 = clonnedhat.Handle
		accweld.Part1 = partath.Parent
		accweld.C0 = hatath.CFrame
		accweld.C1 = partath.CFrame
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.UpperTorso,Vector3.new(0,1.35,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[4]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = (((DeadChar.UpperTorso.CFrame * CFrame.new(0,1.35,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse())
						else
							v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				--[[while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					local alipos = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignPosition")
					local alirot = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignOrientation")
					v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))
				end]]
			end
		end)()
    end
end

game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
DeadChar.Parent = game
local a = DeadChar.UpperTorso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
DeadChar.LowerTorso.Root.Parent = b
DeadChar.Head.Neck.Parent = a
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["Root"].Part1 = told
b["Root"].Part0 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "hum"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
a.Parent = DeadChar
c.Parent = DeadChar
b["Root"]:Destroy()
DeadChar.HumanoidRootPart.Parent = workspace

told:Destroy()
told1:Destroy()
a.Name = "UpperTorso"
DeadChar.Parent = workspace

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end


local con
function UnCollide()
    if HumanDied then con:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetDescendants() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetDescendants() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
con = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
    resetBindable:Destroy()
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
			HumanDied = true
			print("DEAD")
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()

SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.15,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.2,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.85,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.2,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.85,0),Vector3.new(0,0,0))

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.UpperTorso.CFrame * CFrame.new(0,1.35,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in pairs(DeadChar:GetDescendants()) do
    if v.ClassName == "Motor6D" then
        v:Destroy()
    end
end
fldr.Parent = DeadChar

function RUNANIMATESCRIPT(FOLDER)

local Figure = FOLDER.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = FOLDER:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

FOLDER.ChildAdded:connect(scriptChildModified)
FOLDER.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
			
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
				
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
		local deltaTime = time - lastTick
		lastTick = time

	local climbFudge = 0
	local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


local events = {}
local eventHum = Humanoid

local function onUnhook()
	for i = 1, #events do
		events[i]:Disconnect()
	end
	events = {}
end

local function onHook()
	onUnhook()
	
	pose = eventHum.Sit and "Seated" or "Standing"
	
	events = {
		eventHum.Died:connect(onDied),
		eventHum.Running:connect(onRunning),
		eventHum.Jumping:connect(onJumping),
		eventHum.Climbing:connect(onClimbing),
		eventHum.GettingUp:connect(onGettingUp),
		eventHum.FreeFalling:connect(onFreeFall),
		eventHum.FallingDown:connect(onFallingDown),
		eventHum.Seated:connect(onSeated),
		eventHum.PlatformStanding:connect(onPlatformStanding),
		eventHum.Swimming:connect(onSwimming)
	}
end


onHook()
--FOLDER:WaitForChild("Loaded").Value = true


-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

spawn(function()
	while Figure.Parent ~= nil do
		local _, time = wait(0.1)
		move(time)
	end
end)

return {
	onRunning = onRunning, 
	onDied = onDied, 
	onJumping = onJumping, 
	onClimbing = onClimbing, 
	onGettingUp = onGettingUp, 
	onFreeFall = onFreeFall, 
	onFallingDown = onFallingDown, 
	onSeated = onSeated, 
	onPlatformStanding = onPlatformStanding,
	onHook = onHook,
	onUnhook = onUnhook
}

end
RUNANIMATESCRIPT(CloneChar.Animate)

elseif cht:match("VR mode") then

  local InputService = game:GetService("UserInputService")
local Camera = game.Workspace.CurrentCamera
local Player = game.Players.LocalPlayer
local Character = Player.Character
local Head = Character.Head
local Torso = Character.Torso
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local Neck = Torso.Neck
Camera.FieldOfView = 90
Camera.CameraType = "Scriptable"
InputService.MouseBehavior = Enum.MouseBehavior.LockCenter



local v3 = Vector3.new
local cf = CFrame.new
local components = cf().components
local inverse = cf().inverse
local fromAxisAngle = CFrame.fromAxisAngle
local atan,atan2 = math.atan,math.atan2
local acos = math.acos

local function toAxisAngleFromVector(v)
    local z = v.z
    return z*z<0.99999 and v3(v.y,-v.x,0).unit*acos(-z) or v3()
end

local function AxisAngleLookOrientation(c,v,t)
    local c = c-c.p
    local rv = (inverse(c)*v).unit
    local rz = rv.z
    return rz*rz<0.99999 and c*fromAxisAngle(v3(rv.y,-rv.x,0),acos(-rz)*(t or 1)) or c
end

local function AxisAngleLookNew(v,t)--CFrame,Vector,Tween
    local rv = v.unit
    local rz = rv.z
    return rz*rz<0.99999 and fromAxisAngle(v3(rv.y,-rv.x,0),acos(-rz)*(t or 1)) or cf()
end

local function AxisAngleLook(c,v,t)--CFrame,Vector,Tween
    local rv = (inverse(c)*v).unit
    local rz = rv.z
    return rz*rz<0.99999 and c*fromAxisAngle(v3(rv.y,-rv.x,0),acos(-rz)*(t or 1)) or c
end




local Sensitivity = 0.005


local CameraDirection = Vector3.new(0,0,1)

local function EulerAnglesYX(l)
    local x,z = l.x,l.z
    return atan(l.y/(x*x+z*z)^0.5),-atan2(x,-z)
end

local function AnglesXY(l)
    local z = l.z
    return atan2(l.y,-z),-atan2(l.x,-z)
end

local function MouseMoved(Input)
    if Input.UserInputType == Enum.UserInputType.MouseMovement then
        local dx,dy = Input.Delta.x*Sensitivity,Input.Delta.y*Sensitivity
        local m2 = dx*dx+dy*dy
        if m2>0 then
            CameraDirection = (AxisAngleLookOrientation(RootPart.CFrame,CameraDirection)*fromAxisAngle(v3(-dy,-dx,0),m2^0.5)).lookVector
        end
        local RootOrientation = RootPart.CFrame-RootPart.Position
        local RelativeDirection = RootOrientation:inverse()*CameraDirection
        local AngX,AngY = AnglesXY(RelativeDirection)--RootOrientation:inverse()*
        if AngX<-1.57*11/12 then
            local y,z,c,s = RelativeDirection.y,RelativeDirection.z,math.cos(-1.57*11/12-AngX),-math.sin(-1.57*11/12-AngX)
            z,y = z*c-y*s,z*s+y*c
            CameraDirection = RootOrientation*v3(RelativeDirection.x<0 and -(1-y*y-z*z)^0.5 or (1-y*y-z*z)^0.5,y,z)
        elseif AngX>1.57*11/12 then
            local y,z,c,s = RelativeDirection.y,RelativeDirection.z,math.cos(1.57*11/12-AngX),-math.sin(1.57*11/12-AngX)
            z,y = z*c-y*s,z*s+y*c
            CameraDirection = RootOrientation*v3(RelativeDirection.x<0 and -(1-y*y-z*z)^0.5 or (1-y*y-z*z)^0.5,y,z)
        end
    end
end

local Mouse = Player:GetMouse()

local Zoom = -0.5

Mouse.KeyDown:connect(function(k)
    if k == "e" then     
        Zoom = -0.5
    elseif k == "q" then
        Zoom = 8
    end
end)

InputService.InputChanged:connect(MouseMoved)

Neck.C1 = cf()

local _
local DirectionBound = 3.14159/3
local CurrentAngY = 0

local function CameraUpdate()
    Camera.CameraType = "Scriptable"
    local cx,cz = CameraDirection.x,CameraDirection.z
    local rvx,rvz = RootPart.Velocity.x,RootPart.Velocity.z
    if rvx*rvx+rvz*rvz>4 and cx*rvx+cz*rvz<-0.5*(cx*cx+cz*cz)^0.5*(rvx*rvx+rvz*rvz)^0.5 then
        DirectionBound = math.min(DirectionBound*0.9,math.abs(CurrentAngY*0.9))
    else
        DirectionBound = DirectionBound*0.1+3.14159/3*0.9
    end
    local AngX,AngY = EulerAnglesYX((RootPart.CFrame-RootPart.Position):inverse()*CameraDirection)
    if AngY>DirectionBound then
        RootPart.CFrame = RootPart.CFrame*CFrame.Angles(0,AngY-DirectionBound,0)
    elseif AngY<-DirectionBound then
        RootPart.CFrame = RootPart.CFrame*CFrame.Angles(0,AngY+DirectionBound,0)
    end
    _,CurrentAngY = EulerAnglesYX((RootPart.CFrame-RootPart.Position):inverse()*CameraDirection)
    local CameraOrientation = AxisAngleLookNew((RootPart.CFrame-RootPart.Position):inverse()*CameraDirection,1)
    Neck.C0 = CFrame.new(0,1,0)*CameraOrientation*CFrame.new(0,0.5,0)
    local PreCam = AxisAngleLook(RootPart.CFrame*cf(0,1,0),RootPart.CFrame*v3(0,1,0)+CameraDirection)*CFrame.new(0,0.825,0)
    if Zoom == 8 then
        local Part,Position = workspace:findPartOnRay(Ray.new(PreCam.p,PreCam.lookVector*-8),Character)
        Camera.CoordinateFrame = PreCam*CFrame.new(0,0,(Position-PreCam.p).magnitude)
    else
        Camera.CoordinateFrame = PreCam*CFrame.new(0,0,Zoom)
    end
end

game:GetService("RunService").RenderStepped:connect(CameraUpdate)





   end
end)
game:GetService("StarterGui"):SetCore("SendNotification", {

Title = "Status: Working well";
Text = "Prefix is <>";
})500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
wait(0.125)
eff.Enabled = false
end))
MagniDamage(dis, 30, 45,50, 0, "Normal")
    for i = 0, 2 do
		slash(math.random(10,80)/10,5,true,"Round","Add","Out",dis.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,150)/250,dis.BrickColor)
	end
	CFuncs["Sound"].Create("rbxassetid://782353117", dis, 1,1)
	CFuncs["Sound"].Create("rbxassetid://1666361078", dis, 1,1.5)
	CFuncs["Sound"].Create("rbxassetid://782353443", dis, 2,1.65)
	sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.4,0.4,0.4,dis.BrickColor,dis.Color)
end))
game:GetService("Debris"):AddItem(dis, 5)
RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(89),math.rad(-8),math.rad(-5)),0.5)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-30),math.rad(0),math.rad(8)),.5)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-14), math.rad(1), math.rad(17)), 0.5)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.85, 0) * angles(math.rad(180), math.rad(0), math.rad(-8)), 0.5)
RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-8),math.rad(0),math.rad(-20)),.5)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(9),math.rad(0),math.rad(20)),.5)
	end
attack = false
end


local blush = Instance.new("Decal",hed)
blush.Texture = "rbxassetid://898404027"
blush.Face = "Front"
blush.Parent = nil
blush.Transparency = 1
----------------------------------- Abilities

function ExtinctiveHeartbreak()
local targetted = nil
if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
targetted = mouse.Target.Parent
end
if targetted ~= nil then
attack = true
CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
for i = 0, 9 do
sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
end
for i = 0, 24 do
PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
end
sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
local originalpos = root.CFrame
RootPart.CFrame = targetted.Head.CFrame * CFrame.new(0,-2,2)
for i = 0, 9 do
sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
end
for i = 0, 24 do
PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
end
hum.WalkSpeed = 0
sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
local radm = math.random(1,3)
if radm == 1 then
bosschatfunc("YOU WONT BE NECCESSARY.",MAINRUINCOLOR.Color,2)
elseif radm == 2 then
bosschatfunc("YOUR EXISTANCE WILL BE GONE.",MAINRUINCOLOR.Color,2)
elseif radm == 3 then
bosschatfunc("DIE!",MAINRUINCOLOR.Color,2)
end
for i = 0,2,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-10),math.rad(0)),.4)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(80)),.4)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(60)),.4)
end
CFuncs["Sound"].Create("rbxassetid://153092227", root, 5,1)
CFuncs["EchoSound"].Create("rbxassetid://153092227", root, 10, 1,0,10,0.25,0.5,1)
for i = 0,2,0.1 do
swait()
coroutine.resume(coroutine.create(function()
targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
for i,v in pairs(targetted:GetChildren()) do
if v:IsA("Part") or v:IsA("MeshPart") then
v.Velocity = vt(0,0,0)
end
end
end))
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(80)),.8)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(10)),.8)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(90),math.rad(0),math.rad(-80)),.8)
end
CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1,0,10,0.25,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://153092227", char, 1.5, 0.9,0,10,0.25,0.5,1)
for i = 0, 1 do
CFuncs["EchoSound"].Create("rbxassetid://1690476035", char, 1.5, 1,0.1,10,0.15,0.5,1)
end
CFuncs["EchoSound"].Create("rbxassetid://1690476035", root, 10, 1,0.1,10,0.15,0.5,1)
chatfunc("RRRRROOAGHH!",Color3.new(1,0,0),"Inverted","Antique",0.75)
for i = 0,4,0.1 do
swait()
coroutine.resume(coroutine.create(function()
local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
local at1 = Instance.new("Attachment",dis)
at1.Position = vt(-25000,0,0)
local at2 = Instance.new("Attachment",dis)
at2.Position = vt(25000,0,0)
local trl = Instance.new('Trail',dis)
trl.Attachment0 = at1
trl.FaceCamera = true
trl.Attachment1 = at2
trl.Texture = "rbxassetid://1049219073"
trl.LightEmission = 1
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
trl.Color = ColorSequence.new(Color3.new(1,0,0))
trl.Lifetime = 5
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
bv.Parent = dis
game:GetService("Debris"):AddItem(dis, 5)
targetted.Head.CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(-90),0,0)
CFuncs["Sound"].Create("rbxassetid://782353443", targetted.Head, 4,1)
CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 6, 1)
CFuncs["Sound"].Create("rbxassetid://153092227", targetted.Head,6,math.random(75,150)/150)
CFuncs["Sound"].Create("rbxassetid://163680447", targetted.Head, 3,math.random(75,150)/150)
CFuncs["Sound"].Create("rbxassetid://782354021", targetted.Head, 2.5,0.75)
sphere2(5,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
targetted:FindFirstChildOfClass("Humanoid").CameraOffset = vt(math.random(-10,10)/5,math.random(-10,10)/5,math.random(-10,10)/5)
for i = 0, 2 do
slash(5,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(50,350)/250,BrickColor.new("Crimson"))
end
symbolizeBlink(targetted.Head,0,2092248396,Color3.new(1,0,0),math.random(3,35),0,0,0,targetted.Head,true,math.random(3,9),0.25)
for i,v in pairs(targetted:GetChildren()) do
if v:IsA("Part") or v:IsA("MeshPart") then
v.Velocity = vt(0,0,0)
end
end
end))
CamShakeAll(10,90,Character)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0),math.rad(0),math.rad(-80)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(80)),.8)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(20),math.rad(0),math.rad(40)),.8)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(170),math.rad(0),math.rad(-30)),.8)
end
for i = 0, 49 do
local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
dis.CFrame = targetted.Head.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
local at1 = Instance.new("Attachment",dis)
at1.Position = vt(-50000,0,0)
local at2 = Instance.new("Attachment",dis)
at2.Position = vt(50000,0,0)
local trl = Instance.new('Trail',dis)
trl.Attachment0 = at1
trl.FaceCamera = true
trl.Attachment1 = at2
trl.Texture = "rbxassetid://1049219073"
trl.LightEmission = 1
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
trl.Color = ColorSequence.new(Color3.new(1,0.1,0.1))
trl.Lifetime = 5
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
bv.Parent = dis
game:GetService("Debris"):AddItem(dis, 5)
end
for i = 0, 49 do
sphere2(math.random(10,75)/10,"Add",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(5,5,5),-0.05,50,-0.05,MAINRUINCOLOR)
slash(math.random(10,30)/15,5,true,"Round","Add","Out",targetted.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(40,500)/250,BrickColor.new("Really red"))
end
CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 0.9,0,10,0.25,0.5,1)
for i = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 5,0.9)
CFuncs["Sound"].Create("rbxassetid://221920821", targetted.Head, 7.5,0.75)
end
for i = 0, 4 do
CFuncs["Sound"].Create("rbxassetid://824687369", targetted.Head, 10, 1)
end
symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,1)
symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,2)
symbolizeBlink(targetted.Head,0,2109052855,Color3.new(1,0,0),30,0,0,0,root,false,0,4)
dmg(targetted)
CFuncs["Sound"].Create("rbxassetid://847061203", root, 2.5,1)
for i = 0, 9 do
sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
end
for i = 0, 24 do
PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
end
sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
root.CFrame = originalpos
for i = 0, 9 do
sphereMK(3,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("Really red"),0)
end
for i = 0, 24 do
PixelBlock(1,math.random(4,8),"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.06,BrickColor.new("Really red"),0)
end
sphere(3,"Add",root.CFrame,vt(0,0,0),0.25,BrickColor.new("Really red"))
attack = false
hum.WalkSpeed = storehumanoidWS
end
end

function ColorEnbelived()
attack = true
hum.WalkSpeed = 0
chatfunc("Well color me convinced...",Color3.new(0,0,0),"Inverted","Antique",0.75)
for i = 0,50 do
swait()
RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 9 * math.cos(sine / 51))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 7 * math.cos(sine / 44))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 47),0 + 0.25 * math.cos(sine / 35),3 + 1 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(13)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(24 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-13 + 2 * math.cos(sine / 53))),.1)
RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
end
attack = false
hum.WalkSpeed = storehumanoidWS
end

function PlaguedJump()
attack = true
local keptcolor = BrickColor.new("Forest green")
CFuncs["Sound"].Create("rbxassetid://1295446488", root, 10, 1)
CFuncs["EchoSound"].Create("rbxassetid://1657242236", char, 4, 1,0,10,0.15,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://1657242236", root, 10, 1,0,10,0.15,0.5,1)
for i = 0, 5 do
swait()
waveEff(math.random(10,100)/10,"Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),math.random(25,250)/250,0.25,BrickColor.new("White"))
slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,500)/250,BrickColor.new("White"))
end
CamShakeAll(20,100,char)
root.Velocity = vt(0,250,0) + root.CFrame.lookVector*250
wait(0.3)
repeat
swait()
for i = 0, 1, 0.6 do
		swait()
RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
end
for i = 0, 1, 0.6 do
		swait()
RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(90),math.rad(0),math.rad(0)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
end
for i = 0, 1, 0.6 do
		swait()
RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(180),math.rad(0),math.rad(0)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
end
for i = 0, 1, 0.6 do
		swait()
RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-20)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(30)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.2,0)*angles(math.rad(270),math.rad(0),math.rad(0)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.6)
RW.C0=clerp(RW.C0,cf(1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,1.25,0)*angles(math.rad(190),math.rad(0),math.rad(30)),.6)
end
hfr,pfr=rayCast(root.Position,(CFrame.new(root.Position,root.Position - vt(0,1,0))).lookVector,4,char)
until hfr ~= nil
if hfr ~= nil then
local locat = Instance.new("Part", char)
locat.CanCollide = false
locat.FormFactor = 3
locat.Name = "Ring"
locat.Material = "Neon"
locat.Size = Vector3.new(1, 1, 1)
locat.Transparency = 1
locat.TopSurface = 0
locat.BottomSurface = 0
locat.Anchored = true
locat.CFrame = root.CFrame*CFrame.new(0,-3,0)
local poste = 0
local rotation = 0
local upperpos = 0
local rate = 0
local x = locat
CamShakeAll(50,100,char)
CFuncs["Sound"].Create("rbxassetid://847061203", char, 1,1)
CFuncs["Sound"].Create("rbxassetid://763717897", char, 2.5, 1)
CFuncs["Sound"].Create("rbxassetid://1192402877", char, 2.5, 0.5)
sphere(1.25,"Add",root.CFrame,vt(0,0,0),16,MAINRUINCOLOR)
sphere(0.85,"Add",root.CFrame,vt(0,0,0),19,MAINRUINCOLOR)
for i = 0, 49 do
slash(math.random(10,13)/10,2,false,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),vt(0.05,0.01,0.05),math.random(9,14),MAINRUINCOLOR)
end
for i, v in pairs(FindNearestHead(Torso.CFrame.p, 280)) do
if v:FindFirstChild('Torso') then
dmg(v)
end
end
coroutine.resume(coroutine.create(function()
coroutine.resume(coroutine.create(function()
for i = 0, 119 do
sphere2(math.random(1,2),"Add",x.CFrame*CFrame.new(math.random(-350,350),0,math.random(-350,350)),vt(5,1,5),-0.05,math.random(50,250)/50,-0.05,keptcolor)
end
end))
for i = 0, 158 do
swait()
rotation = rotation + 5
poste = poste + 1
upperpos = upperpos + rate
rate = rate + 0.1
sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(90-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(180-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.025,-0.025,-0.025,keptcolor)
sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(270-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(5+upperpos/10,5+upperpos/10,5+upperpos/10),-0.025,-0.025,-0.025,keptcolor)
end
x:Destroy()
end))
end
attack = false
end

function CrazedInsanity()
attack = true
for i = 0,30 do
swait()
sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39) + MRANDOM(-5,5))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45) + MRANDOM(-5,5))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 47),0 - 0.25 * math.cos(sine / 40),7 + 1 * math.cos(sine / 32))*angles(math.rad(-15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(45)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(45)),.5)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(50)),.5)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(10),math.rad(-30)),.5)
end
coroutine.resume(coroutine.create(function()
for i = 0, 2 do
swait()
for i = 0, 2 do
CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10,1)
CFuncs["LongSound"].Create("rbxassetid://763717897", char, 10, 0.5)
CFuncs["LongSound"].Create("rbxassetid://763717897", char, 7.5, 0.25)
CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.9)
CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 0.5)
CFuncs["Sound"].Create("rbxassetid://335657174", char, 5, 0.75)
CFuncs["LongSound"].Create("rbxassetid://335657174", char, 10, 0.25)
CFuncs["Sound"].Create("rbxassetid://167115397", char, 10, 1)
CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.75)
CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.5)
end
for i = 0, 2 do
block(3,"Add",root.CFrame,vt(1,1,1),6.5*2,6.5*2,6.5*2,BrickColor.new("Dark blue"),BrickColor.new("Dark blue").Color)
block(2,"Add",root.CFrame,vt(1,1,1),6*2,6*2,6*2,BrickColor.new("Really Black"),BrickColor.new("Really Black").Color)
block(1,"Add",root.CFrame,vt(1,1,1),4.5*2,4.5*2,4.5*2,BrickColor.new("Dark blue"),BrickColor.new("Dark blue").Color)
end
for i = 0, 49 do
slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,2500)/250,BrickColor.new("Really black"))
end
CamShakeAll(20,120,char)
for i = 0, 199 do
swait()
coroutine.resume(coroutine.create(function()
for i, v in pairs(FindNearestHead(root.CFrame.p, 250)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end
end))
local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
local at1 = Instance.new("Attachment",dis)
at1.Position = vt(-25000,0,0)
local at2 = Instance.new("Attachment",dis)
at2.Position = vt(25000,0,0)
local trl = Instance.new('Trail',dis)
trl.Attachment0 = at1
trl.FaceCamera = true
trl.Attachment1 = at2
trl.Texture = "rbxassetid://1049219073"
trl.LightEmission = 1
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
trl.Color = ColorSequence.new(MAINRUINCOLOR.Color)
trl.Lifetime = 5
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
bv.Parent = dis
game:GetService("Debris"):AddItem(dis, 5)
sphere2(15,"Add",root.CFrame,vt(1.25,1.25,1.25),2.5,2.5,2.5,BrickColor.new("Dark blue"))
for i = 0, 2 do
	CamShakeAll(20,120,char)
slash(15,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),25,BrickColor.new("Dark blue"))
slash(15,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),50,BrickColor.new("Really black"))
end
end
end
end))
for i = 0,60,0.1 do
swait()
sphere2(8,"Add",rleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
sphere2(8,"Add",lleg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39) + MRANDOM(-5,5))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 + MRANDOM(-3,3)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45) + MRANDOM(-5,5))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.25 * math.cos(sine / 47),0 - 0.25 * math.cos(sine / 40),7 + 1 * math.cos(sine / 32))*angles(math.rad(7.5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-15)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30),math.rad(0),math.rad(-15)),.5)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(85),math.rad(0),math.rad(-20)),.5)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(10),math.rad(-30)),.5)
end
attack = false
hum.WalkSpeed = storehumanoidWS
end

function RainbowBeam()
attack = true
CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 1.7)
local rngb = Instance.new("Part", char)
        rngb.Anchored = true
        rngb.BrickColor = origcolor
        rngb.CanCollide = false
        rngb.FormFactor = 3
        rngb.Name = "Ring"
        rngb.Material = "Neon"
        rngb.Size = Vector3.new(1, 0.05, 1)
        rngb.Transparency = 1
        rngb.TopSurface = 0
        rngb.BottomSurface = 0
        local rngmb = Instance.new("SpecialMesh", rngb)
        rngmb.MeshType = "Brick"
rngmb.Name = "SizeMesh"
rngmb.Scale = vt(0,1,0)
local obj1 = script.chring2:Clone()
obj1.Parent = char
obj1.Transparency = 1
obj1.Size = vt(1,1,1)
obj1.Color = BrickColor.new("White").Color
if rainbowmode == true then
obj1.Color = Color3.new(r/255,g/255,b/255)
end
local orb = rngb:Clone()
orb.Parent = char
orb.Transparency = 0
orb.BrickColor = BrickColor.new("White")
orb.Size = vt(1,1,1)
local orbmish = orb.SizeMesh
orbmish.Scale = vt(0,0,0)
orbmish.MeshType = "Sphere"

local orbe = rngb:Clone()
orbe.Parent = char
orbe.Transparency = 0.5
orbe.BrickColor = BrickColor.new("New Yeller")
orbe.Size = vt(1,1,1)
local orbmish2 = orbe.SizeMesh
orbmish2.Scale = vt(0,0,0)
orbmish2.MeshType = "Sphere"
orbe.Color = Color3.new(r/255,g/255,b/255)

rngb:Destroy()
CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local rval = 0
local eval = 1
coroutine.resume(coroutine.create(function()
	for i = 0,7,0.1 do
	swait()
rval = rval + math.random(30,40)
eval = eval + 0.45
obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
	end
end))
RootPart.CFrame = FaceMouse()[1]
for i = 0,5,0.1 do
swait()
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
rval = rval + math.random(30,40)
eval = eval + 0.45
obj1.Transparency = obj1.Transparency - 0.005
obj1.Size = obj1.Size + vt(0.7,0.7,0.1)
obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))

            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)

end
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",obj1)
eff.Texture = "rbxassetid://2273224484"
eff.LightEmission = 1
coroutine.resume(coroutine.create(function()
while true do
	swait()
eff.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
end
end))
eff.Rate = 27500
eff.Lifetime = NumberRange.new(1,2)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(100,650)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
wait(0.35)
eff.Enabled = false
end))
orbe.Transparency = 1
orb.Transparency = 1
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*5
CFuncs["Sound"].Create("rbxassetid://294188875", char, 1, 1)
local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("White")
a.Material = "Neon"
a.Transparency = 0
a.Shape = "Cylinder"
	a.CanCollide = false
local a2 = Instance.new("Part",Character)
	a2.Name = "Direction"	
	a2.Anchored = true
	a2.BrickColor = bc("New Yeller")
a2.Color = Color3.new(r/255,g/255,b/255)
a2.Material = "Neon"
a2.Transparency = 0.5
a2.Shape = "Cylinder"
	a2.CanCollide = false
local ba = Instance.new("Part",Character)
	ba.Name = "HitDirect"	
	ba.Anchored = true
	ba.BrickColor = bc("Cool yellow")
ba.Material = "Neon"
ba.Transparency = 1
	ba.CanCollide = false
	local ray = Ray.new(
	    orb.CFrame.p,                           -- origin
	    (mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	a2.BottomSurface = 10
	a2.TopSurface = 10
	local distance = (orb.CFrame.p - position).magnitude
	a.Size = Vector3.new(distance, 1, 1)
	a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
	a2.Size = Vector3.new(distance, 1, 1)
	a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
game:GetService("Debris"):AddItem(a, 20)
game:GetService("Debris"):AddItem(a2, 20)
game:GetService("Debris"):AddItem(ba, 20)
local msh = Instance.new("SpecialMesh",a)
msh.MeshType = "Cylinder"
msh.Scale = vt(1,5*5,5*5)
local msh2 = Instance.new("SpecialMesh",a2)
msh2.MeshType = "Cylinder"
msh2.Scale = vt(1,6*5,6*5)
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
shakes(0.2,0.8)
rval = rval + math.random(30,40)
eval = eval + 0.45
obj1.Transparency = obj1.Transparency - 0.005
obj1.Size = obj1.Size + vt(0,0,0.075)
obj1.Size = obj1.Size - vt(0.125,0.125,0)
obj1.CFrame = root.CFrame*CFrame.new(0,1,-5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(rval))
a2.Color = Color3.new(r/255,g/255,b/255)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*4
ray = Ray.new(
	    orb.CFrame.p,                           -- origin
	    (mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
	) 
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
a.Size = Vector3.new(distance, 1, 1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
a2.Size = Vector3.new(distance, 1, 1)
a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
msh.Scale = msh.Scale - vt(0,0.025*5,0.025*5)
msh2.Scale = msh2.Scale - vt(0,0.03*5,0.03*5)
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",ba)
eff.Texture = "rbxassetid://2273224484"
eff.LightEmission = 1
eff.Color = ColorSequence.new(Color3.new(r/255,g/255,b/255))
eff.Rate = 50
eff.Lifetime = NumberRange.new(0.5,2)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(50,450)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
wait(0.25)
eff.Enabled = false
end))
sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15*2,15*2,25*2,-0.15,MAINRUINCOLOR,0)
sphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15*2,15*2,25*2,-0.15,MAINRUINCOLOR,0)
MagniDamage(ba, 30*2, 10,20, 0, "Normal")
end
attack = false
	for i = 0,49 do
		swait()
		msh.Scale = msh.Scale - vt(0,0.05*5,0.05*5)
        msh2.Scale = msh2.Scale - vt(0,0.06*5,0.06*5)
		orbe.Transparency = obj1.Transparency + 0.02
		orb.Transparency = obj1.Transparency + 0.02
		obj1.Transparency = obj1.Transparency + 0.02
		obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
	end
a:Destroy()
a2:Destroy()
orb:Destroy()
orbe:Destroy()
wait(3)
obj1:Destroy()
ba:Destroy()
end))
end


function CorruptionEvent()
attack = true
hum.WalkSpeed = 0
CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
local keptcolor = MAINRUINCOLOR
for i = 0,4,0.1 do
swait()
CamShakeAll(10,45,Character)
block(10,"Add",rleg.CFrame*CFrame.new(0,-1,0),vt(1,1,1),0.01,0.01,0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(10)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-10)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-5),math.rad(-10),math.rad(20)),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
end
symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1)
symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1.5)
symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,3)
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1.1,0,10,0.25,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 1.5, 1.1,0,10,0.25,0.5,1)
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",cen)
eff.Texture = "rbxassetid://2344870656"
eff.LightEmission = 1
eff.Color = ColorSequence.new(keptcolor.Color)
eff.Rate = 10000000
eff.Enabled = true
eff.EmissionDirection = "Front"
eff.Lifetime = NumberRange.new(2)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,80,0),NumberSequenceKeypoint.new(1,140,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(500)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.SpreadAngle = Vector2.new(0,900)
eff.RotSpeed = NumberRange.new(-500,500)
wait(0.2)
eff.Enabled = false
wait(5)
eff:Destroy()
	end))
sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
for i = 0, 24 do
slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
end
local rrot = 0
coroutine.resume(coroutine.create(function()
for i = 0, 4 do
rrot = rrot + 45
local xa = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
xa.Anchored = true
local xb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
xb.Anchored = true
local xc = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
xc.Anchored = true
local xd = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
xd.Anchored = true
CFuncs["Sound"].Create("rbxassetid://824687369", xa, 1,0.75)
CFuncs["Sound"].Create("rbxassetid://822968467", xa, 2,0.95)
CFuncs["Sound"].Create("rbxassetid://822969951", xa, 3,1)
CFuncs["Sound"].Create("rbxassetid://824687369", xb, 1,0.75)
CFuncs["Sound"].Create("rbxassetid://822968467", xb, 2,0.95)
CFuncs["Sound"].Create("rbxassetid://822969951", xb, 3,1)
CFuncs["Sound"].Create("rbxassetid://824687369", xc, 1,0.75)
CFuncs["Sound"].Create("rbxassetid://822968467", xc, 2,0.95)
CFuncs["Sound"].Create("rbxassetid://822969951", xc, 3,1)
CFuncs["Sound"].Create("rbxassetid://824687369", xd, 1,0.75)
CFuncs["Sound"].Create("rbxassetid://822968467", xd, 2,0.95)
CFuncs["Sound"].Create("rbxassetid://822969951", xd, 3,1)
xa.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,-rrot/1.75)
xb.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(0,-3,rrot/1.75)
xc.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(-rrot/1.75,-3,0)
xd.CFrame = root.CFrame*CFrame.Angles(0,math.rad(rrot),0)*CFrame.new(rrot/1.75,-3,0)
MagniDamage(xa, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
MagniDamage(xb, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
MagniDamage(xc, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
MagniDamage(xd, 30, 39*rrot/5,65*rrot/2.5, 0, "Normal")
for i = 0, 9 do
slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
slash(math.random(15,50)/10,5,true,"Round","Add","Out",xb.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
slash(math.random(15,50)/10,5,true,"Round","Add","Out",xc.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
slash(math.random(15,50)/10,5,true,"Round","Add","Out",xd.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,125)/250,BrickColor.new("Really black"))
end
block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
block(1.5,"Add",xb.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
block(1.5,"Add",xc.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
block(1.5,"Add",xd.CFrame*CFrame.new(0,-10,0),vt(30,30,30),0.3,0.3,0.3,keptcolor,keptcolor.Color)
sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
sphere2(2,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
sphere2(2,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
sphere2(2,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25,1,25),0.05,1.5,0.05,keptcolor,keptcolor.Color)
sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
sphere2(4,"Add",xb.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
sphere2(4,"Add",xc.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
sphere2(4,"Add",xd.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30,1,30),0.05,1.5,0.05,BrickColor.new("Really black"),Color3.new(0,0,0))
game:GetService("Debris"):AddItem(xa, 5)
game:GetService("Debris"):AddItem(xb, 5)
game:GetService("Debris"):AddItem(xc, 5)
game:GetService("Debris"):AddItem(xd, 5)
coroutine.resume(coroutine.create(function()
for i = 0, 19 do
swait()
CamShakeAll(10,75,Character)
end
end))
swait(9)
end
end))
for i = 0,2,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(10)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(10)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(0)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(40),math.rad(0),math.rad(0)),.8)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-35),math.rad(-10),math.rad(60)),.8)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
end
attack = false
hum.WalkSpeed = storehumanoidWS
end

function HolyBarrier()
	attack = true
	shielding = true
	CFuncs["Sound"].Create("rbxassetid://1368583274", root, 7.5, 1)
	for i = 0, 2, 0.1 do
        swait()
		slash(math.random(30,100)/10,5,true,"Round","Add","Out",Torso.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1, 1)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),vt(0.05,0.01,0.05),math.random(50,60)/250,MAINRUINCOLOR)
		RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(60),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-2 - 1 * math.cos(sine / 32))),.4)
		LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(-20),math.rad(-90),math.rad(0))*angles(math.rad(-3 + 1 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.4)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.5 + 0.1 * math.cos(sine / 32))*angles(math.rad(30),math.rad(0),math.rad(0)),.4)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0)),.4)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(120),math.rad(-230),math.rad(-40)),.1)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(120),math.rad(230),math.rad(40)),.1)
	end
	CFuncs["Sound"].Create("rbxassetid://1368637781", root, 7, 1)
    stash = Instance.new("Model",workspace)
	local barrier = Instance.new("Part",stash)
	barrier.Anchored = true
	barrier.CanCollide = false
	barrier.Size = Vector3.new(20,20,20)
	barrier.CFrame = root.CFrame
	barrier.Transparency = 0.4
	barrier.BrickColor = MAINRUINCOLOR
	barrier.Material = Enum.Material.Neon
	barrier.Shape = Enum.PartType.Ball
	barrier.CFrame = root.CFrame
	sphere(3, "Add", root.CFrame, vt(20, 20, 20), 0.15, MAINRUINCOLOR)
	Torso.Anchored = true
	for i=1,50 do
		local p = Instance.new("Part",stash)
		p.Anchored = true
		p.Transparency = 1
		p.Size = Vector3.new(11,11,11)
		p.CFrame = root.CFrame * CFrame.Angles(math.random(0,360),math.random(0,360),math.random(0,360))
	end
	repeat
		swait(5)
        CamShakeAll(10,7,Character)
		waveEff(5,"Add","In",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),-0.075,0.05,BrickColor.new("Deep orange"))
		slash(math.random(30,100)/10,1,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(1,50)/250,MAINRUINCOLOR)
		slash(math.random(30,100)/10,1,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(1,50)/250,MAINRUINCOLOR)
		slash(math.random(30,100)/10,1,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(1,50)/250,MAINRUINCOLOR)
		sphereMK(3,0.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,10,-0.01,BrickColor.new("White"),0)
	until shielding == false
	stash:Remove()
	Torso.Anchored = false
	shielding = false
	sphere(3, "Add", root.CFrame, vt(20, 20, 20), 0.15, MAINRUINCOLOR)
	attack = false
end

function EndGROUND()
	attack = true
hum.WalkSpeed = 0
bosschatfunc("THIS IS IT!",MAINRUINCOLOR.Color,1)
CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
CFuncs["EchoSound"].Create("rbxassetid://1690475123", char, 1.5, 1,0,10,0.15,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://1690475123", root, 10, 1,0,10,0.15,0.5,1)
local keptcolor = MAINRUINCOLOR
for i = 0,4,0.1 do
swait()
block(10,"Add",rarm.CFrame*CFrame.new(0,-6,0),vt(4,4,4),0.05,0.05,0.05,MAINRUINCOLOR,MAINRUINCOLOR.Color)
slash(math.random(25,50)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-6,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-15),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(30)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-30)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(170),math.rad(-5),math.rad(10)),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
end
symbolizeBlink(root,0,2109052855,MAINRUINCOLOR.Color,25,0,0,0,root,false,0,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1,0,10,0.25,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 1,0,10,0.25,0.5,1)
coroutine.resume(coroutine.create(function()
CamShakeAll(40,100,Character)
local eff = Instance.new("ParticleEmitter",cen)
eff.Texture = "rbxassetid://2344870656"
eff.LightEmission = 1
eff.Color = ColorSequence.new(keptcolor.Color)
eff.Rate = 10000000
eff.Enabled = true
eff.EmissionDirection = "Front"
eff.Lifetime = NumberRange.new(2)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.1,40,0),NumberSequenceKeypoint.new(0.8,80,0),NumberSequenceKeypoint.new(1,140,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(500)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.SpreadAngle = Vector2.new(0,900)
eff.RotSpeed = NumberRange.new(-500,500)
wait(0.2)
eff.Enabled = false
wait(5)
eff:Destroy()
end))
sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
for i = 0, 24 do
slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
end
local rrot = 0
local xam = 1
coroutine.resume(coroutine.create(function()
for i = 0, 14 do
swait()
rrot = rrot + 40*xam
xam = xam + 0.25
local bonus = xam
local xa = CreateParta(char,0.5,1,"Neon",BrickColor.random())
xa.Anchored = true
xa.Color = Color3.new(0,0,0)
xa.CFrame = root.CFrame*CFrame.new(0,-3,-rrot/1.75)
CreateMesh(xa,"Sphere",30*bonus,1,30*bonus)
local xc = 0
coroutine.resume(coroutine.create(function()
for i = 0, 99 do
	swait()
	xc = xc + 0.01
	xa.Color = Color3.new(xc,0,0)
end
xa.Transparency = 1
CFuncs["Sound"].Create("rbxassetid://331666100", xa, 5,0.75)
MagniDamage(xa, 30*bonus, 78*bonus,99*bonus, 0, "Normal")
for i = 0, 9 do
slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01*bonus,0.01,0.01*bonus),math.random(50,125)/250*bonus,BrickColor.new("Really black"))
end
CamShakeAll(20,100,xa)
block(1.5,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30*bonus,30*bonus,30*bonus),0.3,0.3,0.3,keptcolor,keptcolor.Color)
sphere2(2,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(25*bonus,1,25*bonus),0.05*bonus,1.5*bonus,0.05*bonus,keptcolor,keptcolor.Color)
sphere2(4,"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(30*bonus,1,30*bonus),0.05*bonus,1.5*bonus,0.05*bonus,BrickColor.new("Really black"),Color3.new(0,0,0))
game:GetService("Debris"):AddItem(xa, 5)
end))
end
end))
for i = 0,2,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-25),math.rad(30)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.5)*angles(math.rad(30),math.rad(0),math.rad(50)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-50)),.8)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(35),math.rad(-10),math.rad(30)),.8)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
end
attack = false
hum.WalkSpeed = storehumanoidWS
end

function ClearDisk()
attack = true
hum.WalkSpeed = 2
local keptcolor = MAINRUINCOLOR
local radm = math.random(1,3)
if radm == 1 then
bosschatfunc("Clear Disks!",MAINRUINCOLOR.Color,1)
elseif radm == 2 then
bosschatfunc("TAKE THAT!!!",MAINRUINCOLOR.Color,1)
elseif radm == 3 then
bosschatfunc("Hey!",MAINRUINCOLOR.Color,1)
end
CFuncs["Sound"].Create("rbxassetid://847061203", root, 2, 1)
CFuncs["EchoSound"].Create("rbxassetid://1625448638", root, 4, 1,0,10,0.15,0.5,1)
sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.1,0.1,0.1,keptcolor,keptcolor.Color)
sphere2(5,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(1,1,1),0.2,0.2,0.2,keptcolor,keptcolor.Color)
for i = 0, 14 do
PixelBlock(1,math.random(1,3),"Add",larm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,0.02,BrickColor.new("Pastel Blue"),0)
end
for i = 0,2,0.1 do
swait()
sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.3)
LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.3)
end
CFuncs["Sound"].Create("rbxassetid://763755889", root, 2.5,1.1)
for i = 0,1,0.6 do
swait()
sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
end
for i = 0,1,0.6 do
swait()
sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
end
for i = 0,1,0.6 do
swait()
sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
end
for i = 0,1,0.6 do
swait()
sphere2(8,"Add",larm.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(math.rad(90),0,0),vt(2.25,0.1,2.25),0.01,0.01,0.01,keptcolor,keptcolor.Color)
slash(math.random(15,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,75)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-5)),.6)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(30),math.rad(0)),.6)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(270)),.6)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(30)),.6)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(10)),.6)
LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(60)),.6)
end
local rot = 25
for i = 0, 3 do
local dis = CreateParta(char,0.5,1,"Neon",BrickColor.new("Pastel Blue"))
CFuncs["EchoSound"].Create("rbxassetid://763718160", dis, 3, 1.1,0,10,0.15,0.5,1)
dis.CFrame = root.CFrame*CFrame.new(0,2,-3)
dis.Transparency = 0.5
CreateMesh(dis,"Sphere",10,1,10)
local at1 = Instance.new("Attachment",dis)
at1.Position = vt(-5,0,0)
local at2 = Instance.new("Attachment",dis)
at2.Position = vt(5,0,0)
local trl = Instance.new('Trail',wed)
trl.Attachment0 = at1
trl.Attachment1 = at2
trl.Texture = "rbxassetid://1049219073"
trl.LightEmission = 1
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
trl.Color = ColorSequence.new(dis.Color)
trl.Lifetime = 0.6
local a = Instance.new("Part",workspace)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    dis.CFrame.p,                           -- origin
	    (mouse.Hit.p - dis.CFrame.p).unit * 500 -- direction
	) 
	local ignore = dis
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (dis.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(dis.CFrame.p, position) * CFrame.new(0, 0, 0)
dis.CFrame = a.CFrame
dis.CFrame = dis.CFrame*CFrame.Angles(0,math.rad(rot),0)
a:Destroy()
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = dis.CFrame.lookVector*250
bv.Parent = dis
game:GetService("Debris"):AddItem(dis, 5)
local hitted = false
coroutine.resume(coroutine.create(function()
dis.Touched:connect(function(hit) 
	if hitted == false and hit.Parent ~= char then
	hitted = true
    CamShakeAll(20,35,Character)
	CFuncs["EchoSound"].Create("rbxassetid://782200047", dis, 7, 1.1,0,10,0.15,0.5,1)
	MagniDamage(dis, 30, 82,34575, 0, "Normal")
	sphere2(8,"Add",dis.CFrame,vt(10,1,10),1,0.1,1,keptcolor,keptcolor.Color)
	sphere2(4,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,keptcolor,keptcolor.Color)
	sphere2(3,"Add",dis.CFrame,vt(1,1,1),0.5,0.5,0.5,BrickColor.new("White"),Color3.new(1,1,1))
	coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",dis)
eff.Texture = "rbxassetid://2344870656"
eff.LightEmission = 1
eff.Color = ColorSequence.new(dis.Color)
eff.Rate = 10000000
eff.Enabled = true
eff.EmissionDirection = "Front"
eff.Lifetime = NumberRange.new(1)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,75,0),NumberSequenceKeypoint.new(0.1,20,0),NumberSequenceKeypoint.new(0.8,40,0),NumberSequenceKeypoint.new(1,60,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(150)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.SpreadAngle = Vector2.new(0,900)
eff.RotSpeed = NumberRange.new(-500,500)
wait(0.2)
eff.Enabled = false
	end))
	coroutine.resume(coroutine.create(function()
		for i = 0, 9 do
local disr = CreateParta(char,1,1,"Neon",keptcolor)
disr.CFrame = dis.CFrame*CFrame.Angl
